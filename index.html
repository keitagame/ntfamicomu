<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>FMU</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="nes.png" type="image/png">
    <style>
       :root {
        color-scheme: light;
      }
      @font-face {
  font-family: "Renner";
  src: url("./Renner.ttf") format("truetype");
  font-display: swap;
 
}
      body {
        background:rgb(255, 255, 255);
       font-family: "Renner", sans-serif;
        margin: 0;
        padding:0;
      }
h1{
font-weight:300;
font-size:25px;
}
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas{
        
        height: 100%;              /* コンテナ幅に合わせる */
      aspect-ratio: 256 / 240;  /* 内部解像度の比率を維持 */
        image-rendering: pixelated;
        border: 1px solid #000000;
        background: #000;
      }
      .row {
        padding-top:0px;
height:83vh;
justify-content: center; 
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
       font-size:20px; 
      }
      small {
        opacity: 0.7;
      }
      







    </style>
  </head>
  <body>
   
    <header>
<h1>FAMICOMU</h1>
      <select style="display:none" id="romSelect">
  <option value="">-- サーバーROMを選択 --</option>
  <option value="snow.nes">snow.nes</option>
  <option value="cmc.nes">cmc.nes</option>
  <option value="roms/sw.nes">sw.nes</option>
  <option value="roms/bs.nes">bs.nes</option>
    <option value="roms/dh2.nes">dh.nes</option>
  
</select>

  <input id="rom" type="file" class="file-input">

<label class="file-label" style="display:none">
  Load FDS BIOS
  <input id="fdsBios" type="file" class="file-input">
</label>

<label class="file-label" style="display:none">
  Load FDS Disk
  <input id="fdsDisk" type="file" class="file-input">
</label>

<span id="file-name"></span>

      
      <button id="fullscreenBtn">Fullscreen</button>

      <button id="start">Start</button>
      <div class="mono" id="status" style="display:none">No ROM</div>
      <div><span class="mono">CPU PC:</span> <span id="pc" class="mono">0x0000</span></div>
    </header>
    <div class="row">
      <canvas id="screen" width="256" height="240"></canvas>
      <div style="display:none">
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>
        <div><b>CPU S:</b><span id="ram" class="mono">0x0000</span></div>
        <div><b>CPU P:</b><span id="mapper" class="mono">0x0000</span></div>

        <small
          >Skeleton: Mapper0, iNES, PPU frame timing + NMI, CPU bus/IRQs, opcode
          hooks</small
        >
      </div>
    </div>

    

    <script type="module">
      let fdsBios = null; // Uint8Array (8192 bytes)
let fdsDisk = null; // Uint8Array (.fds)
let isFDS = false;

      const u8 = (n) => n & 0xff;
      const u16 = (n) => n & 0xffff;
      const lo = (n) => n & 0xff;
      const hi = (n) => (n >> 8) & 0xff;
      const NES_PALETTE = [
        0x666666ff, 0x002a88ff, 0x1412a7ff, 0x3b00a4ff, 0x5c007eff, 0x6e0040ff,
        0x6c0600ff, 0x561d00ff, 0x333500ff, 0x0b4800ff, 0x005200ff, 0x004f08ff,
        0x00404dff, 0x000000ff, 0x000000ff, 0x000000ff, 0xadadadff, 0x155fd9ff,
        0x4240ffff, 0x7527feff, 0xa01accff, 0xb71e7bff, 0xb53120ff, 0x994e00ff,
        0x6b6d00ff, 0x388700ff, 0x0c9300ff, 0x008f32ff, 0x007c8dff, 0x000000ff,
        0x000000ff, 0x000000ff, 0xffffffff, 0x64b0ffff, 0x9290ffff, 0xc676ffff,
        0xf26affff, 0xff6eccff, 0xff8170ff, 0xea9e22ff, 0xbcbe00ff, 0x88d800ff,
        0x5ce430ff, 0x45e082ff, 0x48cddeff, 0x4f4f4fff, 0x000000ff, 0x000000ff,
        0xffffffff, 0xc0dfffff, 0xd3d2ffff, 0xe8c8ffff, 0xfbc2ffff, 0xffc4eaff,
        0xffccc5ff, 0xf7d8a5ff, 0xe4e594ff, 0xcfef96ff, 0xbdf4abff, 0xb3f3ccff,
        0xb5ebf2ff, 0xb8b8b8ff, 0x000000ff, 0x000000ff,
      ];
      class IMapper {
        constructor(cart, bus) {
          this.cart = cart;
          this.bus = bus;
          this.prg = cart.prg;
          this.chr = cart.chr || new Uint8Array(0x2000);
          this.chrIsRAM = cart.chrIsRAM;
          this.mirrorMode = cart.mirror;
          this.prgRAM = cart.prgRAM || new Uint8Array(0x2000);
        }
        
        cpuRead(addr) {
          return 0;
        }
        cpuWrite(addr, val) {}
       
        ppuRead(addr) {
          return 0;
        }
        ppuWrite(addr, val) {}
        
        mirroring() {
          return this.mirrorMode;
        }
        
        getSaveRAM() {
          return this.prgRAM;
        }
      }

      const MapperRegistry = {
  0: (cart, bus) => new Mapper0(cart, bus),
  1: (cart, bus) => new Mapper1(cart, bus),
  2: (cart, bus) => new Mapper2(cart, bus),
  3: (cart, bus) => new Mapper3(cart, bus),
  4: (cart, bus) => new Mapper4(cart, bus),
  5: (cart, bus) => new Mapper5(cart, bus),   // MMC5
  7: (cart, bus) => new Mapper7(cart, bus),
  9: (cart, bus) => new Mapper9(cart, bus),
  10: (cart, bus) => new Mapper10(cart, bus),
  11: (cart, bus) => new Mapper11(cart, bus),
  13: (cart, bus) => new Mapper13(cart, bus),
  15: (cart, bus) => new Mapper15(cart, bus),
  16: (cart, bus) => new Mapper16(cart, bus),
  18: (cart, bus) => new Mapper18(cart, bus),
  19: (cart, bus) => new Mapper19(cart, bus),  // Namco 163
  20: (cart, bus) => new Mapper20(cart, bus, fdsBios, fdsDisk),
  21: (cart, bus) => new Mapper21(cart, bus),  // VRC4a
  22: (cart, bus) => new Mapper22(cart, bus),  // VRC2a
  23: (cart, bus) => new Mapper23(cart, bus),  // VRC2b/4e
  24: (cart, bus) => new Mapper24(cart, bus),  // VRC6a
  25: (cart, bus) => new Mapper25(cart, bus),  // VRC4b/d
  26: (cart, bus) => new Mapper26(cart, bus),  // VRC6b
  30: (cart, bus) => new Mapper30(cart, bus),
  34: (cart, bus) => new Mapper34(cart, bus),
  66: (cart, bus) => new Mapper66(cart, bus),
  69: (cart, bus) => new Mapper69(cart, bus),  // FME-7
  71: (cart, bus) => new Mapper71(cart, bus),
  73: (cart, bus) => new Mapper73(cart, bus),  // VRC3
  75: (cart, bus) => new Mapper75(cart, bus),
  76: (cart, bus) => new Mapper76(cart, bus),
  78: (cart, bus) => new Mapper78(cart, bus),
  79: (cart, bus) => new Mapper79(cart, bus),
  85: (cart, bus) => new Mapper85(cart, bus),  // VRC7
  86: (cart, bus) => new Mapper86(cart, bus),
  87: (cart, bus) => new Mapper87(cart, bus),
  88: (cart, bus) => new Mapper88(cart, bus),
  89: (cart, bus) => new Mapper89(cart, bus),
  93: (cart, bus) => new Mapper93(cart, bus),
  94: (cart, bus) => new Mapper94(cart, bus),
  95: (cart, bus) => new Mapper95(cart, bus),
  97: (cart, bus) => new Mapper97(cart, bus),
  105: (cart, bus) => new Mapper105(cart, bus),
  113: (cart, bus) => new Mapper113(cart, bus),
  115: (cart, bus) => new Mapper115(cart, bus),
  118: (cart, bus) => new Mapper118(cart, bus),
  119: (cart, bus) => new Mapper119(cart, bus),
  144: (cart, bus) => new Mapper144(cart, bus),
  148: (cart, bus) => new Mapper148(cart, bus),
  152: (cart, bus) => new Mapper152(cart, bus),
  180: (cart, bus) => new Mapper180(cart, bus),
  184: (cart, bus) => new Mapper184(cart, bus),
  185: (cart, bus) => new Mapper185(cart, bus),
  206: (cart, bus) => new Mapper206(cart, bus),
  228: (cart, bus) => new Mapper228(cart, bus),
};

      function createMapper(cart, bus) {
        const ctor = MapperRegistry[cart.mapper];
        if (!ctor) throw new Error(`未対応マッパー: ${cart.mapper}`);
        return ctor(cart, bus);
      }
class Mapper0 extends IMapper {
  constructor(cart) {
    super(cart);

    this.prg = cart.prg;
    this.prgSize = this.prg.length;

    if (cart.chr && cart.chr.length > 0) {
      // CHR ROM
      this.chr = cart.chr;
      this.chrIsRAM = false;
    } else {
      // CHR RAM (8KB)
      this.chr = new Uint8Array(0x2000);
      this.chrIsRAM = true;
    }
  }

  cpuRead(addr) {
    if (addr < 0x8000) return 0;
    let a = addr - 0x8000;
    if (this.prgSize === 0x4000) a &= 0x3FFF;
    return this.prg[a];
  }

  cpuWrite(addr, val) {
    // Mapper 0: 何もしない
  }

  ppuRead(addr) {
    if (addr < 0x2000) {
      return this.chr[addr & 0x1FFF];
    }
    return 0;
  }

  ppuWrite(addr, val) {
    if (addr < 0x2000 && this.chrIsRAM) {
      this.chr[addr & 0x1FFF] = val & 0xFF;
    }
  }
}

    
      class Mapper2 extends IMapper {
        constructor(cart) {
          super(cart);
          this.prg = cart.prg;
          this.chr = cart.chr || new Uint8Array(0x2000);
          this.chrIsRAM = cart.chrIsRAM;
          this.bank = 0; 
          this.fixedBank = this.prg.length / 0x4000 - 1; // last bank at $C000-$FFFF
        }
        cpuRead(addr) {
          if (addr < 0x8000) return 0;
          if (addr < 0xc000) {
            const base = (this.bank & 0x0f) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          } else {
            const base = this.fixedBank * 0x4000;
            return this.prg[base + (addr - 0xc000)];
          }
        }
        cpuWrite(addr, val) {
          if (addr >= 0x8000) this.bank = val & 0x0f;
        }
        ppuRead(addr) {
          if (addr < 0x2000) return this.chr[addr];
          return 0;
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val;
        }
      }
      class Mapper3 extends IMapper {
        constructor(cart) {
          super(cart);
          this.prg = cart.prg;
          this.chr = cart.chr || new Uint8Array(0x2000);
          this.chrIsRAM = cart.chrIsRAM;
          this.chrBank = 0;
        }
        cpuRead(addr) {
          if (addr < 0x8000) return 0;
          const a = addr - 0x8000;
          if (this.prg.length === 0x4000) {
            // mirror 16K
            return this.prg[a & 0x3fff];
          }
          return this.prg[a];
        }
        cpuWrite(addr, val) {
          if (addr >= 0x8000) this.chrBank = val & 0x03;
        }
        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank & 0x03) * 0x2000; // 8KB bank (一部CNROMは4KB、ROMに依存)
            return this.chr[base + addr];
          }
          return 0;
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val;
        }
      }
      class Mapper1 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);

    this.shiftReg = 0x10; // 10000b
    this.writeCount = 0;

    this.control = 0x0C; // PRG mode = 3
    this.chrBank0 = 0;
    this.chrBank1 = 0;
    this.prgBank = 0;
  }

  resetShift() {
    this.shiftReg = 0x10;
    this.writeCount = 0;
  }

  cpuWrite(addr, val) {
    if (addr < 0x8000) return;

    if (val & 0x80) {
      // reset
      this.resetShift();
      this.control |= 0x0C;
      return;
    }

    // shift in LSB
    this.shiftReg = (this.shiftReg >> 1) | ((val & 1) << 4);
    this.writeCount++;

    if (this.writeCount === 5) {
      const reg = (addr >> 13) & 3;
      const data = this.shiftReg & 0x1F;

      switch (reg) {
        case 0:
          this.control = data;
          break;
        case 1:
          this.chrBank0 = data;
          break;
        case 2:
          this.chrBank1 = data;
          break;
        case 3:
          this.prgBank = data & 0x0F;
          break;
      }
      this.resetShift();
    }
  }

  cpuRead(addr) {
    if (addr < 0x8000) return 0;

    const prgMode = (this.control >> 2) & 3;
    const prgBanks = this.prg.length / 0x4000;
    let bank = 0;
    let offset = addr & 0x3FFF;

    if (prgMode <= 1) {
      // 32KB
      bank = (this.prgBank & 0x0E);
      return this.prg[(bank * 0x4000) + (addr - 0x8000)];
    }

    if (prgMode === 2) {
      // $8000 fixed
      bank = addr < 0xC000 ? 0 : this.prgBank;
    } else {
      // $C000 fixed
      bank = addr < 0xC000 ? this.prgBank : (prgBanks - 1);
    }

    return this.prg[(bank * 0x4000) + offset];
  }

  ppuRead(addr) {
    if (addr >= 0x2000) return 0;

    const chrMode = (this.control >> 4) & 1;

    if (!chrMode) {
      // 8KB
      const base = (this.chrBank0 & 0x1E) * 0x1000;
      return this.chr[base + addr];
    }

    if (addr < 0x1000) {
      const base = this.chrBank0 * 0x1000;
      return this.chr[base + addr];
    } else {
      const base = this.chrBank1 * 0x1000;
      return this.chr[base + (addr - 0x1000)];
    }
  }

  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) {
      this.chr[addr] = val & 0xFF;
    }
  }

  mirroring() {
    switch (this.control & 3) {
      case 0: return 2; // single-screen lower
      case 1: return 3; // single-screen upper
      case 2: return 1; // vertical
      case 3: return 0; // horizontal
    }
  }
}

      class Mapper4 {
        constructor(cart) {
          this.cart = cart;

          // PRG/CHR data

          this.prg = cart.prg; // Uint8Array (ROM)
          this.chr = cart.chr;
          this.hasChrRam = !!cart.chrIsRAM;

          this.prgRam = cart.prgRAM || new Uint8Array(0x2000); // 8KB
          this.prgRamEnabled = true;
          // Banking registers
          this.bankSelect = 0; // $8000
          this.bankRegs = new Uint8Array(8); // $8001 target 0..7
          this.prgMode = 0; // $8000 bit6
          this.chrMode = 0; // $8000 bit7

          // Effective bank maps
          this.prgBankMap = new Int32Array(4); // 4 x 8KB banks for $8000,$A000,$C000,$E000
          this.chrBankMap = new Int32Array(8); // 8 x 1KB banks 0..7

          // Mirroring
          this.mirror = cart.mirror; // 0:H, 1:V (default from header); overridden by $A000

          // IRQ
          this.irqLatch = 0; // $C000
          this.irqCounter = 0; // internal counter
          this.irqReload = false; // latched when $C001 written; reloads on next A12 rise
          this.irqEnabled = false; // $E001 enables, $E000 disables+ack
          this.irqPending = false;

          // A12 edge detector with low filter (~8 PPU cycles)
          this.prevA12 = 0;
          this.a12LowCooldown = 0; // counts PPU cycles while A12 low

          // Init fixed banks
          this.resetBanks();
        }

        resetBanks() {
          // Init PRG banks: last 16KB must be fixed across modes
          const prg8kBanks = this.prg.length >>> 13; // / 0x2000
          // Safety against small PRG sizes
          const last = Math.max(0, prg8kBanks - 1);
          const last2 = Math.max(0, prg8kBanks - 2);

          // Default bank regs:
          this.bankRegs[6] = 0; // switchable
          this.bankRegs[7] = 1; // switchable
          // CHR regs default to 0..7

          for (let i = 0; i < 6; i++) this.bankRegs[i] = i; // 0..5
          this.bankRegs[6] = 6;
          this.bankRegs[7] = 7;
          this.updateChrMap();

          // Build maps
          this.updatePrgMap();
          this.updateChrMap();
        }

        // ----- CPU space -----

        cpuRead(addr) {
          if (addr >= 0x6000 && addr < 0x8000) {
            if (!this.prgRamEnabled) return 0x00;
            return this.prgRam[addr & 0x1fff];
          }
          if (addr >= 0x8000) {
            const slot = (addr - 0x8000) >>> 13; // 0..3
            const bank = this.prgBankMap[slot]; // 8KB bank index
            const off = addr & 0x1fff;
            const base = (bank & this._prgBankMask()) << 13;
            return this.prg[base + off] | 0;
          }
          return 0;
        }

        cpuWrite(addr, val) {
          val &= 0xff;

          if (addr >= 0x6000 && addr < 0x8000) {
            if (!this.prgRamEnabled) return;
            this.prgRam[addr & 0x1fff] = val;
            return;
          }

          if (addr >= 0x8000 && addr <= 0x9fff) {
            if ((addr & 1) === 0) {
              // $8000 even: bank select
              this.bankSelect = val & 0x07; // target 0..7
              this.prgMode = (val >>> 6) & 1; // bit6
              this.chrMode = (val >>> 7) & 1; // bit7
              this.updatePrgMap();
              this.updateChrMap();
            } else {
              // $8001 odd: bank data
              const i = this.bankSelect & 7;
              this.bankRegs[i] = val;
              // R0,R1 are 2KB units; R2-R5 are 1KB; R6,R7 are 8KB
              if (i <= 5) this.updateChrMap();
              else this.updatePrgMap();
            }
            return;
          }

          if (addr >= 0xa000 && addr <= 0xbfff) {
            if ((addr & 1) === 0) {
              // $A000 even: mirroring control (bit0: 0=vertical,1=horizontal)
              this.mirror = val & 1 ? 0 : 1; // convert to your mirroring enum: 0:H,1:V
            } else {
              // $A001 odd: PRG-RAM protect/enable (simplified)
              // Common behavior: bit7 enables RAM; bit6 write-protect; implementations vary.
              this.prgRamEnabled = (val & 0x80) !== 0 || true; // permissive default if unsure
            }
            return;
          }

          if (addr >= 0xc000 && addr <= 0xdfff) {
            if ((addr & 1) === 0) {
              // $C000 even: IRQ latch
              this.irqLatch = val;
            } else {
              // $C001 odd: IRQ reload on next A12 rising edge
              this.irqReload = true;
            }
            return;
          }

          if (addr >= 0xe000 && addr <= 0xffff) {
            if ((addr & 1) === 0) {
              // $E000 even: IRQ disable + acknowledge
              this.irqEnabled = false;
              this.irqPending = false;
              this.cart.bus?.requestIRQ && this.cart.bus.requestIRQ(false); // optional clear
            } else {
              // $E001 odd: IRQ enable
              this.irqEnabled = true;
            }
            return;
          }
        }

        // ----- PPU space -----

        ppuRead(addr) {
          addr &= 0x3fff;
          if (addr < 0x2000) {
            // MMC3 IRQ counter clocks on PPU A12 rising edges, with A12-low filter.
            this._clockA12(addr);

            const bank1k = this.chrBankMap[addr >>> 10]; // 1KB bank index
            const base = (bank1k & this._chrBankMask()) << 10;
            const off = addr & 0x03ff;
            return this.chr[base + off] | 0;
          }
          // >= 0x2000 handled by PPU not mapper
          return 0;
        }

        ppuWrite(addr, val) {
          addr &= 0x3fff;
          val &= 0xff;
          if (addr < 0x2000 && this.hasChrRam) {
            this._clockA12(addr);
            const bank1k = this.chrBankMap[addr >>> 10];
            const base = (bank1k & this._chrBankMask()) << 10;
            const off = addr & 0x03ff;
            this.chr[base + off] = val;
          }
        }

        _prgBankMask() {
          return (this.prg.length >>> 13) - 1;
        }
        _chrBankMask() {
          return (this.chr.length >>> 10) - 1;
        }

        _prgBanks() {
          return this.prg.length >>> 13;
        } // 8KB単位数
        _chrBanks() {
          return this.chr.length >>> 10;
        } // 1KB単位数

        updatePrgMap() {
          const prgBanks = this.prg.length >>> 13;
          const last = Math.max(0, prgBanks - 1);
          const last2 = Math.max(0, prgBanks - 2);

          const b6 = this.bankRegs[6] & this._prgBankMask(); // 8KB
          const b7 = this.bankRegs[7] & this._prgBankMask();

          if (this.prgMode === 0) {
            // $8000=b6, $A000=b7, $C000=last2, $E000=last
            this.prgBankMap[0] = b6;
            this.prgBankMap[1] = b7;
            this.prgBankMap[2] = last2;
            this.prgBankMap[3] = last;
          } else {
            // $8000=last2, $A000=b7, $C000=b6, $E000=last
            this.prgBankMap[0] = last2;
            this.prgBankMap[1] = b7;
            this.prgBankMap[2] = b6;
            this.prgBankMap[3] = last;
          }
        }

        updateChrMap() {
          // R0,R1 are 2KB units; R2-R5 are 1KB units
          // Layout depends on chrMode (bit7 of $8000)
          const r = this.bankRegs;

          // Expand R0,R1 (2KB) into 1KB indices by clearing LSB per spec
          const r0 = r[0] & 0xfe;
          const r1 = r[1] & 0xfe;
          const r2 = r[2],
            r3 = r[3],
            r4 = r[4],
            r5 = r[5];

          if (this.chrMode === 0) {
            // $0000: R0(2KB) → banks 0,1
            this.chrBankMap[0] = r0 + 0;
            this.chrBankMap[1] = r0 + 1;
            // $0800: R1(2KB) → banks 2,3
            this.chrBankMap[2] = r1 + 0;
            this.chrBankMap[3] = r1 + 1;
            // $1000..$1FFF: R2..R5 as 1KB
            this.chrBankMap[4] = r2;
            this.chrBankMap[5] = r3;
            this.chrBankMap[6] = r4;
            this.chrBankMap[7] = r5;
          } else {
            // $0000..$0FFF: R2..R5
            this.chrBankMap[0] = r2;
            this.chrBankMap[1] = r3;
            this.chrBankMap[2] = r4;
            this.chrBankMap[3] = r5;
            // $1000: R0(2KB)
            this.chrBankMap[4] = r0 + 0;
            this.chrBankMap[5] = r0 + 1;
            // $1800: R1(2KB)
            this.chrBankMap[6] = r1 + 0;
            this.chrBankMap[7] = r1 + 1;
          }

          // Mask to available CHR banks
          const m = this._chrBankMask();
          for (let i = 0; i < 8; i++) this.chrBankMap[i] &= m;
        }

        // ----- IRQ clocking by A12 rising edges -----

        _clockA12(addr) {
          const a12 = (addr >>> 12) & 1;

          // Track A12 low time to filter bursts; decrement cooldown when A12==0
          if (a12 === 0) {
            if (this.a12LowCooldown < 12) this.a12LowCooldown++;
          }

          // Rising edge detection with low-time qualification
          if (this.prevA12 === 0 && a12 === 1 && this.a12LowCooldown >= 8) {
            this._onA12Rising();
            this.a12LowCooldown = 0; // reset low counter; need fresh low period before next count
          }

          this.prevA12 = a12;
        }

        _onA12Rising() {
          // Reload behavior
          if (this.irqReload || this.irqCounter === 0) {
            this.irqCounter = this.irqLatch;
            this.irqReload = false;
          } else {
            this.irqCounter = (this.irqCounter - 1) & 0xff;
          }

          if (this.irqCounter === 0 && this.irqEnabled) {
            this.irqPending = true;
            // Signal IRQ to bus/CPU
            if (this.cart.bus && this.cart.bus.requestIRQ) {
              this.cart.bus.requestIRQ(true);
            }
          }
        }

        // Called by Bus for mirroring queries
        mirroring() {
          // Your Bus expects 0: H, 1: V
          return this.mirror;
        }
      }
      class Mapper7 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x8000; // 32KB units
          this.bank = 0;
          this.singleScreen = 0; // 0/1 → nametable base
        }
        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
          const base = (this.bank % this.prgBanks) * 0x8000;
          return this.prg[base + (addr - 0x8000)];
        }
        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.bank = val & 0x0f;
            this.singleScreen = (val >> 4) & 1; // bit4: mirroring select
          }
        }
        ppuRead(addr) {
          if (addr < 0x2000) return this.chr[addr]; // usually CHR-RAM
          return 0;
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xff;
        }

        // Bus.ntMirror を拡張したくない場合、ここで single-screen を H/V に近似することも可能
        mirroring() {
          // single-screen: nametable 0 or 1。Bus側が H/V 前提なら暫定で vertical に固定でも可。
          // ここでは Bus 側に single-screen を渡せないため、近似として vertical を返す。
          return 1;
        }
      }
      class Mapper66 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x8000;
          this.chrBanks = Math.max(1, this.chr.length / 0x2000);
          this.prgBank = 0;
          this.chrBank = 0;
        }
        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
          const base = (this.prgBank % this.prgBanks) * 0x8000;
          return this.prg[base + (addr - 0x8000)];
        }
        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.prgBank = (val >> 4) & 0x0f; // upper nibble
            this.chrBank = (val & 0x0f) % this.chrBanks; // lower nibble
          }
        }
        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            return this.chr[base + addr];
          }
          return 0;
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xff;
        }
      }
      class Mapper9 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          // 4KB CHR banks for left/right halves
          this.chrBankL0 = 0; // $0000-$0FFF latch=0
          this.chrBankL1 = 0; // latch=1
          this.chrBankR0 = 0; // $1000-$1FFF latch=0
          this.chrBankR1 = 0; // latch=1
          this.latchL = 0; // 0 or 1
          this.latchR = 0; // 0 or 1
          this.prgBank = 0; // 16KB @ $8000; $C000 固定末尾

          this.prgBanks16 = this.prg.length / 0x4000;
          this.chrBanks4k = this.chr.length / 0x1000;

          // PPU hook
          const origPPURead = bus.ppu.ppuRead.bind(bus.ppu);
          bus.ppu.ppuRead = (addr) => {
            this.onPPUAddr(addr & 0x3fff);
            return origPPURead(addr);
          };
        }
        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
          if (addr < 0xc000) {
            const base = (this.prgBank % this.prgBanks16) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          }
          const base = (this.prgBanks16 - 1) * 0x4000;
          return this.prg[base + (addr - 0xc000)];
        }
        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0xa000 && addr <= 0xafff) {
            this.chrBankL0 = val % this.chrBanks4k;
          } else if (addr >= 0xb000 && addr <= 0xbfff) {
            this.chrBankL1 = val % this.chrBanks4k;
          } else if (addr >= 0xc000 && addr <= 0xcfff) {
            this.chrBankR0 = val % this.chrBanks4k;
          } else if (addr >= 0xd000 && addr <= 0xdfff) {
            this.chrBankR1 = val % this.chrBanks4k;
          } else if (addr >= 0xe000 && addr <= 0xefff) {
            this.prgBank = val & 0x0f;
          } else if (addr >= 0xf000 && addr <= 0xffff) {
            // mirroring: 0=vertical, 1=horizontal
            this.mirrorMode = val & 1 ? 0 : 1; // NES仕様: bit0=mirroring (ここはROMにより差異あり)
          }
        }
        ppuRead(addr) {
          if (addr >= 0x2000) return 0;
          const a = addr & 0x0fff;
          if (addr < 0x1000) {
            const base4k =
              (this.latchL ? this.chrBankL1 : this.chrBankL0) * 0x1000;
            return this.chr[base4k + a];
          } else {
            const base4k =
              (this.latchR ? this.chrBankR1 : this.chrBankR0) * 0x1000;
            return this.chr[base4k + a];
          }
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xff;
        }

        onPPUAddr(addr) {
          // Latch points: reads from $0FD8 → L=0, $0FE8 → L=1; similarly on right side $1FD8/$1FE8 → R latch
          if ((addr & 0x1000) === 0) {
            // left side ($0000-$0FFF)
            if ((addr & 0x0fff) === 0x0fd8) this.latchL = 0;
            else if ((addr & 0x0fff) === 0x0fe8) this.latchL = 1;
          } else {
            // right side ($1000-$1FFF)
            if ((addr & 0x0fff) === 0x0fd8) this.latchR = 0;
            else if ((addr & 0x0fff) === 0x0fe8) this.latchR = 1;
          }
        }

        mirroring() {
          return this.mirrorMode;
        }
      }
      class Mapper10 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          // 4KB banks
          this.chrLeft0 = 0; // latch=0
          this.chrLeft1 = 0; // latch=1
          this.chrRight = 0; // fixed 4KB
          this.latchL = 0;

          this.prgBank = 0; // 16KB @ $8000; $C000 固定末尾
          this.prgBanks16 = this.prg.length / 0x4000;
          this.chrBanks4k = this.chr.length / 0x1000;

          const origPPURead = bus.ppu.ppuRead.bind(bus.ppu);
          bus.ppu.ppuRead = (addr) => {
            this.onPPUAddr(addr & 0x3fff);
            return origPPURead(addr);
          };
        }
        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
          if (addr < 0xc000) {
            const base = (this.prgBank % this.prgBanks16) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          }
          const base = (this.prgBanks16 - 1) * 0x4000;
          return this.prg[base + (addr - 0xc000)];
        }
        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0xa000 && addr <= 0xafff) {
            this.chrLeft0 = val % this.chrBanks4k;
          } else if (addr >= 0xb000 && addr <= 0xbfff) {
            this.chrLeft1 = val % this.chrBanks4k;
          } else if (addr >= 0xc000 && addr <= 0xcfff) {
            this.chrRight = val % this.chrBanks4k;
          } else if (addr >= 0xd000 && addr <= 0xdfff) {
            this.prgBank = val & 0x0f;
          } else if (addr >= 0xe000 && addr <= 0xffff) {
            // mirroring
            this.mirrorMode = val & 1 ? 1 : 0;
          }
        }
        ppuRead(addr) {
          if (addr >= 0x2000) return 0;
          const a = addr & 0x0fff;
          if (addr < 0x1000) {
            const base4k =
              (this.latchL ? this.chrLeft1 : this.chrLeft0) * 0x1000;
            return this.chr[base4k + a];
          } else {
            const base4k = this.chrRight * 0x1000;
            return this.chr[base4k + a];
          }
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xff;
        }

        onPPUAddr(addr) {
          // MMC4 latch points: $0FD8 sets latch=0, $0FE8 sets latch=1 on left
          if ((addr & 0x1000) === 0) {
            // left
            const low = addr & 0x0fff;
            if (low === 0x0fd8) this.latchL = 0;
            else if (low === 0x0fe8) this.latchL = 1;
          }
        }
        mirroring() {
          return this.mirrorMode;
        }
      }
class Mapper20 extends IMapper {
  constructor(cart, bus, bios, disk) {
    super(cart, bus)
    this.bios = bios          // 8KB
    this.disk = disk          // fds image
    this.diskInserted = true
  }

  cpuRead(addr) {
    // BIOS ROM
    
    if (addr >= 0xE000) {
      return this.bios[addr - 0xE000]
    }

    // FDS I/O status
    if (addr === 0x4030) return 0x80   // disk inserted
    if (addr === 0x4031) return 0x00
    if (addr === 0x4032) return 0x00   // READY
    if (addr === 0x4033) return 0x00

    return 0
  }

  cpuWrite(addr, val) {
    // モーターON/OFF 等（今回は無視）
  }
}

      class Mapper30 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBank = 0; // $8000-$BFFF
          this.fixedBank = this.prg.length / 0x4000 - 1; // $C000-$FFFF
          // CHR-RAM banking: assume 8KB banks over larger RAM (allocate if needed)
          if (this.chrIsRAM && this.chr.length < 0x20000) {
            // expand to 128KB RAM for banking demo if desired
            const big = new Uint8Array(0x20000);
            big.set(this.chr);
            this.chr = big;
          }
          this.chrBank = 0; // 8KB
          this.maxChrBanks = this.chr.length / 0x2000;
        }
        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
          if (addr < 0xc000) {
            const base = (this.prgBank % (this.fixedBank + 1)) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          }
          const base = this.fixedBank * 0x4000;
          return this.prg[base + (addr - 0xc000)];
        }
        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr === 0x8000) {
            this.prgBank = val & 0x0f;
          } else if (addr === 0x8001) {
            this.chrBank = val % this.maxChrBanks;
          }
        }
        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank % this.maxChrBanks) * 0x2000;
            return this.chr[base + addr];
          }
          return 0;
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) {
            const base = (this.chrBank % this.maxChrBanks) * 0x2000;
            this.chr[base + addr] = val & 0xff;
          }
        }
      }
      class Mapper71 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBank = 0;
          this.fixedBank = this.prg.length / 0x4000 - 1;
        }
        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
          if (addr < 0xc000) {
            const base = (this.prgBank % (this.fixedBank + 1)) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          }
          const base = this.fixedBank * 0x4000;
          return this.prg[base + (addr - 0xc000)];
        }
        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.prgBank = val & 0x0f;
            this.mirrorMode = val & 0x10 ? 1 : 0; // bit4 controls mirroring
          }
        }
        ppuRead(addr) {
          if (addr < 0x2000) return this.chr[addr];
          return 0;
        }
        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xff;
        }
        mirroring() {
          return this.mirrorMode;
        }
      }
      class Mapper75 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x4000; // 16KB 単位
          this.chrBanks = this.chr.length / 0x1000; // 4KB 単位
          this.prgBank = 0;
          this.chrBank0 = 0;
          this.chrBank1 = 1;
          this.fixedBank = this.prgBanks - 1;
        }

        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];

          if (addr < 0xc000) {
            const base = (this.prgBank % this.prgBanks) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          } else {
            const base = this.fixedBank * 0x4000;
            return this.prg[base + (addr - 0xc000)];
          }
        }

        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }

          switch (addr & 0xf000) {
            case 0x8000:
              this.prgBank = val & 0x0f; // PRG 16KB
              break;
            case 0x9000:
              this.chrBank0 = val & 0x1f; // CHR 4KB (lower)
              break;
            case 0xa000:
              this.chrBank1 = val & 0x1f; // CHR 4KB (upper)
              break;
          }
        }

        ppuRead(addr) {
          if (addr < 0x1000) {
            const base = (this.chrBank0 % this.chrBanks) * 0x1000;
            return this.chr[base + addr];
          } else if (addr < 0x2000) {
            const base = (this.chrBank1 % this.chrBanks) * 0x1000;
            return this.chr[base + (addr - 0x1000)];
          }
          return 0;
        }

        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) {
            if (addr < 0x1000) {
              const base = (this.chrBank0 % this.chrBanks) * 0x1000;
              this.chr[base + addr] = val & 0xff;
            } else {
              const base = (this.chrBank1 % this.chrBanks) * 0x1000;
              this.chr[base + (addr - 0x1000)] = val & 0xff;
            }
          }
        }
      }

      class Mapper79 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x4000; // 16KB 単位
          this.chrBanks = this.chr.length / 0x2000; // 8KB 単位
          if (!this.chr) {
            this.chr = new Uint8Array(0x2000);
            this.chrIsRAM = true;
          }
          this.prgBank = 0;
          this.chrBank = 0;
          this.fixedBank = this.prgBanks - 1; // 最後の16KB固定
        }

        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];

          if (addr < 0xc000) {
            const base = (this.prgBank % this.prgBanks) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          } else {
            const base = this.fixedBank * 0x4000;
            return this.prg[base + (addr - 0xc000)];
          }
        }

        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.prgBank = val & 0x0f; // 下位4bit → PRGバンク
            this.chrBank = (val >> 4) & 0x0f; // 上位4bit → CHRバンク
          }
        }

        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            return this.chr[base + addr];
          }
          return 0;
        }

        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            this.chr[base + addr] = val & 0xff;
          }
        }
      }
      class Mapper115 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x4000; // 16KB 単位
          this.chrBanks = this.chr.length / 0x2000; // 8KB 単位
          this.prgBank = 0;
          this.chrBank = 0;
          this.fixedBank = this.prgBanks - 1; // 最後の16KB固定
        }

        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];

          if (addr < 0xc000) {
            const base = (this.prgBank % this.prgBanks) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          } else {
            const base = this.fixedBank * 0x4000;
            return this.prg[base + (addr - 0xc000)];
          }
        }

        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.prgBank = val & 0x0f; // 下位4bit → PRG
            this.chrBank = (val >> 4) & 0x0f; // 上位4bit → CHR
          }
        }

        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            return this.chr[base + addr];
          }
          return 0;
        }

        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            this.chr[base + addr] = val & 0xff;
          }
        }
      }

      class Mapper144 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x8000; // 32KB 単位
          this.chrBanks = this.chr.length / 0x2000; // 8KB 単位
          this.prgBank = 0;
          this.chrBank = 0;
        }

        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];

          // 32KB バンク切り替え
          const base = (this.prgBank % this.prgBanks) * 0x8000;
          return this.prg[base + (addr - 0x8000)];
        }

        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.prgBank = val & 0x0f; // 下位4bit → PRG
            this.chrBank = (val >> 4) & 0x0f; // 上位4bit → CHR
          }
        }

        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            return this.chr[base + addr];
          }
          return 0;
        }

        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            this.chr[base + addr] = val & 0xff;
          }
        }
      }

      class Mapper148 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x4000; // 16KB 単位
          this.chrBanks = this.chr.length / 0x2000; // 8KB 単位
          this.prgBank = 0;
          this.chrBank = 0;
          this.fixedBank = this.prgBanks - 1; // 最後の16KB固定
        }

        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];

          if (addr < 0xc000) {
            const base = (this.prgBank % this.prgBanks) * 0x4000;
            return this.prg[base + (addr - 0x8000)];
          } else {
            const base = this.fixedBank * 0x4000;
            return this.prg[base + (addr - 0xc000)];
          }
        }

        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.prgBank = val & 0x0f; // 下位4bit → PRGバンク
            this.chrBank = (val >> 4) & 0x0f; // 上位4bit → CHRバンク
          }
        }

        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            return this.chr[base + addr];
          }
          return 0;
        }

        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            this.chr[base + addr] = val & 0xff;
          }
        }
      }
      class Mapper228 extends IMapper {
        constructor(cart, bus) {
          super(cart, bus);
          this.prgBanks = this.prg.length / 0x8000; // 32KB 単位
          this.chrBanks = this.chr.length / 0x2000; // 8KB 単位
          this.prgBank = 0;
          this.chrBank = 0;
        }

        cpuRead(addr) {
          if (addr < 0x6000) return 0;
          if (addr < 0x8000) return this.prgRAM[addr - 0x6000];

          // 32KB バンク切り替え
          const base = (this.prgBank % this.prgBanks) * 0x8000;
          return this.prg[base + (addr - 0x8000)];
        }

        cpuWrite(addr, val) {
          val &= 0xff;
          if (addr >= 0x6000 && addr < 0x8000) {
            this.prgRAM[addr - 0x6000] = val;
            return;
          }
          if (addr >= 0x8000) {
            this.prgBank = val & 0x0f; // 下位4bit → PRG
            this.chrBank = (val >> 4) & 0x0f; // 上位4bit → CHR
          }
        }

        ppuRead(addr) {
          if (addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            return this.chr[base + addr];
          }
          return 0;
        }

        ppuWrite(addr, val) {
          if (this.chrIsRAM && addr < 0x2000) {
            const base = (this.chrBank % this.chrBanks) * 0x2000;
            this.chr[base + addr] = val & 0xff;
          }
        }
      }
// MapperRegistryセクションを以下に置き換え：

// 既存のMapper実装の後に以下を追加：

// Mapper 5 (MMC5) - 基本実装
class Mapper5 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgMode = 3;
    this.chrMode = 0;
    this.prgBanks = [0, 0, 0, this.prg.length / 0x2000 - 1];
    this.chrBanks = new Uint8Array(12);
    this.exRAM = new Uint8Array(0x400);
    this.ramMode = 0;
  }
  
  cpuRead(addr) {
    if (addr < 0x6000) return 0;
    if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
    
    const bank = (addr - 0x8000) >> 13;
    const offset = addr & 0x1FFF;
    const base = (this.prgBanks[bank] % (this.prg.length / 0x2000)) * 0x2000;
    return this.prg[base + offset];
  }
  
  cpuWrite(addr, val) {
    val &= 0xFF;
    if (addr >= 0x6000 && addr < 0x8000) {
      this.prgRAM[addr - 0x6000] = val;
      return;
    }
    if (addr === 0x5100) this.prgMode = val & 3;
    else if (addr === 0x5101) this.chrMode = val & 3;
    else if (addr >= 0x5114 && addr <= 0x5117) {
      this.prgBanks[addr - 0x5114] = val;
    } else if (addr >= 0x5120 && addr <= 0x512B) {
      this.chrBanks[addr - 0x5120] = val;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const bank = addr >> 10;
      const base = (this.chrBanks[bank] % (this.chr.length / 0x400)) * 0x400;
      return this.chr[base + (addr & 0x3FF)];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

// Mapper 11 (Color Dreams)
class Mapper11 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBank = 0;
    this.chrBank = 0;
  }
  
  cpuRead(addr) {
    if (addr < 0x8000) return 0;
    const base = (this.prgBank % (this.prg.length / 0x8000)) * 0x8000;
    return this.prg[base + (addr - 0x8000)];
  }
  
  cpuWrite(addr, val) {
    if (addr >= 0x8000) {
      this.prgBank = val & 0x0F;
      this.chrBank = (val >> 4) & 0x0F;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const base = (this.chrBank % (this.chr.length / 0x2000)) * 0x2000;
      return this.chr[base + addr];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

// Mapper 13 (CPROM)
class Mapper13 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.chrBank = 0;
    this.chr = new Uint8Array(0x4000);
    this.chrIsRAM = true;
  }
  
  cpuRead(addr) {
    if (addr < 0x8000) return 0;
    return this.prg[addr - 0x8000];
  }
  
  cpuWrite(addr, val) {
    if (addr >= 0x8000) this.chrBank = val & 0x03;
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const base = this.chrBank * 0x1000;
      return this.chr[base + (addr & 0xFFF)];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (addr < 0x2000) {
      const base = this.chrBank * 0x1000;
      this.chr[base + (addr & 0xFFF)] = val & 0xFF;
    }
  }
}

// Mapper 15 (Multi-cart)
class Mapper15 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBank = 0;
    this.mode = 0;
  }
  
  cpuRead(addr) {
    if (addr < 0x8000) return 0;
    const base = (this.prgBank % (this.prg.length / 0x4000)) * 0x4000;
    if (this.mode === 2) {
      return this.prg[(base * 2) + (addr - 0x8000)];
    }
    return this.prg[base + ((addr - 0x8000) & 0x3FFF)];
  }
  
  cpuWrite(addr, val) {
    if (addr >= 0x8000) {
      this.prgBank = val & 0x3F;
      this.mode = (val >> 6) & 3;
      this.mirrorMode = (val & 0x40) ? 0 : 1;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) return this.chr[addr];
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

// Mapper 16 (Bandai FCG)
class Mapper16 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBank = 0;
    this.chrBanks = new Uint8Array(8);
  }
  
  cpuRead(addr) {
    if (addr < 0x6000) return 0;
    if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
    if (addr < 0xC000) {
      const base = (this.prgBank % (this.prg.length / 0x4000)) * 0x4000;
      return this.prg[base + (addr - 0x8000)];
    }
    const base = ((this.prg.length / 0x4000) - 1) * 0x4000;
    return this.prg[base + (addr - 0xC000)];
  }
  
  cpuWrite(addr, val) {
    val &= 0xFF;
    if (addr >= 0x6000 && addr < 0x8000) {
      this.prgRAM[addr - 0x6000] = val;
      return;
    }
    if (addr >= 0x8000) {
      const reg = addr & 0x0F;
      if (reg <= 7) this.chrBanks[reg] = val;
      else if (reg === 8) this.prgBank = val & 0x0F;
      else if (reg === 9) this.mirrorMode = val & 1 ? 0 : 1;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const bank = addr >> 10;
      const base = (this.chrBanks[bank] % (this.chr.length / 0x400)) * 0x400;
      return this.chr[base + (addr & 0x3FF)];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

// Mapper 18 (Jaleco SS8806)
class Mapper18 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBanks = [0, 1, this.prg.length / 0x2000 - 1];
    this.chrBanks = new Uint8Array(8);
  }
  
  cpuRead(addr) {
    if (addr < 0x6000) return 0;
    if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
    
    const slot = (addr - 0x8000) >> 13;
    const base = (this.prgBanks[slot] % (this.prg.length / 0x2000)) * 0x2000;
    return this.prg[base + (addr & 0x1FFF)];
  }
  
  cpuWrite(addr, val) {
    val &= 0xFF;
    if (addr >= 0x6000 && addr < 0x8000) {
      this.prgRAM[addr - 0x6000] = val;
      return;
    }
    if (addr >= 0x8000 && addr <= 0x8003) {
      const slot = addr & 3;
      if (slot < 3) this.prgBanks[slot] = val & 0x1F;
    } else if (addr >= 0xA000 && addr <= 0xD003) {
      const chrSlot = ((addr - 0xA000) >> 1) & 7;
      this.chrBanks[chrSlot] = val;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const bank = addr >> 10;
      const base = (this.chrBanks[bank] % (this.chr.length / 0x400)) * 0x400;
      return this.chr[base + (addr & 0x3FF)];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

// Mapper 19 (Namco 163) - 簡易版
class Mapper19 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBanks = [0, 0, 0, this.prg.length / 0x2000 - 1];
    this.chrBanks = new Uint8Array(8);
    this.ntRAM = new Uint8Array(0x1000);
  }
  
  cpuRead(addr) {
    if (addr < 0x6000) return 0;
    if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
    
    const slot = (addr - 0x8000) >> 13;
    const base = (this.prgBanks[slot] % (this.prg.length / 0x2000)) * 0x2000;
    return this.prg[base + (addr & 0x1FFF)];
  }
  
  cpuWrite(addr, val) {
    val &= 0xFF;
    if (addr >= 0x6000 && addr < 0x8000) {
      this.prgRAM[addr - 0x6000] = val;
      return;
    }
    if (addr >= 0x8000 && addr <= 0x87FF) {
      this.chrBanks[(addr >> 8) & 7] = val;
    } else if (addr >= 0xE000 && addr <= 0xE7FF) {
      this.prgBanks[(addr >> 8) & 3] = val & 0x3F;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const bank = addr >> 10;
      const base = (this.chrBanks[bank] % (this.chr.length / 0x400)) * 0x400;
      return this.chr[base + (addr & 0x3FF)];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

// Mapper 21/23/25 (VRC4/VRC2) - 統合簡易版
class Mapper21 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBanks = [0, 0, (this.prg.length / 0x2000) - 1];
    this.chrBanks = new Uint8Array(8);
  }
  
  cpuRead(addr) {
    if (addr < 0x6000) return 0;
    if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
    if (addr < 0xA000) {
      const base = (this.prgBanks[0] % (this.prg.length / 0x2000)) * 0x2000;
      return this.prg[base + (addr - 0x8000)];
    }
    if (addr < 0xC000) {
      const base = (this.prgBanks[1] % (this.prg.length / 0x2000)) * 0x2000;
      return this.prg[base + (addr - 0xA000)];
    }
    const base = this.prgBanks[2] * 0x2000;
    return this.prg[base + (addr - 0xC000)];
  }
  
  cpuWrite(addr, val) {
    val &= 0xFF;
    if (addr >= 0x6000 && addr < 0x8000) {
      this.prgRAM[addr - 0x6000] = val;
      return;
    }
    if (addr >= 0x8000 && addr <= 0x8FFF) this.prgBanks[0] = val & 0x1F;
    else if (addr >= 0xA000 && addr <= 0xAFFF) this.prgBanks[1] = val & 0x1F;
    else if (addr >= 0xB000 && addr <= 0xEFFF) {
      const chrReg = ((addr >> 12) - 0xB) * 2 + ((addr >> 1) & 1);
      if (chrReg < 8) this.chrBanks[chrReg] = val;
    } else if (addr >= 0x9000 && addr <= 0x9FFF) {
      this.mirrorMode = val & 1;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const bank = addr >> 10;
      const base = (this.chrBanks[bank] % (this.chr.length / 0x400)) * 0x400;
      return this.chr[base + (addr & 0x3FF)];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

class Mapper22 extends Mapper21 {} // VRC2a
class Mapper23 extends Mapper21 {} // VRC2b/4e
class Mapper25 extends Mapper21 {} // VRC4b/d

// Mapper 24/26 (VRC6)
class Mapper24 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBanks = [0, 0, (this.prg.length / 0x2000) - 1];
    this.chrBanks = new Uint8Array(8);
  }
  
  cpuRead(addr) {
    if (addr < 0x6000) return 0;
    if (addr < 0x8000) return this.prgRAM[addr - 0x6000];
    
    const slot = (addr < 0xC000) ? (addr < 0xA000 ? 0 : 1) : 2;
    const base = (this.prgBanks[slot] % (this.prg.length / 0x2000)) * 0x2000;
    return this.prg[base + (addr & 0x1FFF)];
  }
  
  cpuWrite(addr, val) {
    val &= 0xFF;
    if (addr >= 0x6000 && addr < 0x8000) {
      this.prgRAM[addr - 0x6000] = val;
      return;
    }
    if (addr >= 0x8000 && addr <= 0x8003) this.prgBanks[0] = val & 0x0F;
    else if (addr >= 0xC000 && addr <= 0xC003) this.prgBanks[1] = val & 0x1F;
    else if (addr >= 0xD000 && addr <= 0xE003) {
      const chrReg = ((addr - 0xD000) >> 2) * 2 + (addr & 3);
      if (chrReg < 8) this.chrBanks[chrReg] = val;
    } else if (addr >= 0xB003 && addr <= 0xB003) {
      this.mirrorMode = val & 1;
    }
  }
  
  ppuRead(addr) {
    if (addr < 0x2000) {
      const bank = addr >> 10;
      const base = (this.chrBanks[bank] % (this.chr.length / 0x400)) * 0x400;
      return this.chr[base + (addr & 0x3FF)];
    }
    return 0;
  }
  
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

class Mapper26 extends Mapper24 {} // VRC6b

// 他のMapper (34, 69, 73, 76, 78, 85, 86, 87, 88, 89, 93, 94, 95, 97, 105, 113, 118, 119, 180, 184, 185, 206)
// 以下簡易実装を追加

class Mapper34 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBank = 0;
    this.chrBank = 0;
  }
  cpuRead(addr) {
    if (addr < 0x8000) return 0;
    if (addr < 0xC000) {
      const base = (this.prgBank % (this.prg.length / 0x8000)) * 0x8000;
      return this.prg[base + (addr - 0x8000)];
    }
    const base = ((this.prg.length / 0x8000) - 1) * 0x8000;
    return this.prg[base + (addr - 0xC000)];
  }
  cpuWrite(addr, val) {
    if (addr >= 0x7FFD && addr <= 0x7FFF) this.prgBank = val;
    else if (addr >= 0x8000) this.chrBank = val;
  }
  ppuRead(addr) {
    if (addr < 0x2000) {
      const base = (this.chrBank % (this.chr.length / 0x2000)) * 0x2000;
      return this.chr[base + addr];
    }
    return 0;
  }
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}

class Mapper69 extends Mapper16 {} // FME-7 (similar to 16)
class Mapper73 extends IMapper { // VRC3 - PRG only
  constructor(cart, bus) {
    super(cart, bus);
    this.prgBank = 0;
  }
  cpuRead(addr) {
    if (addr < 0x8000) return 0;
    if (addr < 0xC000) {
      const base = (this.prgBank % (this.prg.length / 0x4000)) * 0x4000;
      return this.prg[base + (addr - 0x8000)];
    }
    const base = ((this.prg.length / 0x4000) - 1) * 0x4000;
    return this.prg[base + (addr - 0xC000)];
  }
  cpuWrite(addr, val) {
    if (addr >= 0xF000) this.prgBank = val & 0x0F;
  }
  ppuRead(addr) {
    if (addr < 0x2000) return this.chr[addr];
    return 0;
  }
  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) this.chr[addr] = val & 0xFF;
  }
}
class Mapper76 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);

    /* ================= PRG ================= */

    // 8KB banks
    this.prgBanks8 = this.prg.length >> 13; // /0x2000
    this.prgMap = new Uint8Array(4);

    /* ================= CHR ================= */

    // 2KB banks (Mapper76 = coarse banking)
    this.chrBanks2k = Math.max(1, this.chr.length >> 11); // /0x800
    this.chrMap = new Uint32Array(4); // base addresses for 2KB slots

    /* ================= Registers ================= */

    this.regSelect = 0;
    this.reg = new Uint8Array(8);

    this.reset();
  }

  /* ================= RESET ================= */

  reset() {
    // Clear registers
    for (let i = 0; i < 8; i++) {
      this.reg[i] = 0;
    }

    // Initial PRG mapping
    this.prgMap[0] = 0;
    this.prgMap[1] = 1;
    this.prgMap[2] = this.prgBanks8 - 2;
    this.prgMap[3] = this.prgBanks8 - 1;

    // Initial CHR mapping
    for (let i = 0; i < 4; i++) {
      this.chrMap[i] = (i % this.chrBanks2k) << 11;
    }
  }

  /* ================= CPU ================= */

  cpuRead(addr) {
    if (addr < 0x8000) return 0;

    const slot = (addr - 0x8000) >> 13; // 8KB slot
    const bank = this.prgMap[slot] % this.prgBanks8;
    const base = bank << 13;

    return this.prg[base + (addr & 0x1FFF)];
  }

  cpuWrite(addr, val) {
    val &= 0xFF;

    // Mask: $E001
    switch (addr & 0xE001) {
      case 0x8000:
        // Register select (0-7)
        this.regSelect = val & 7;
        break;

      case 0x8001:
        // Write to selected register
        this.reg[this.regSelect] = val;
        this.updateBanks();
        break;
    }
  }

  /* ================= BANK UPDATE ================= */

  updateBanks() {
    /* ===== PRG ===== */
    // R6 -> $8000
    // R7 -> $A000
    // $C000 = fixed -2
    // $E000 = fixed -1

    this.prgMap[0] = this.reg[6] % this.prgBanks8;
    this.prgMap[1] = this.reg[7] % this.prgBanks8;
    this.prgMap[2] = this.prgBanks8 - 2;
    this.prgMap[3] = this.prgBanks8 - 1;

    /* ===== CHR ===== */
    // R2-R5 each control 2KB
    for (let i = 0; i < 4; i++) {
      const bank2k = this.reg[2 + i] % this.chrBanks2k;
      this.chrMap[i] = bank2k << 11; // 2KB = 0x800
    }
  }

  /* ================= PPU ================= */

  ppuRead(addr) {
    if (addr >= 0x2000) return 0;

    const slot = addr >> 11; // 2KB slot (0-3)
    const base = this.chrMap[slot];

    return this.chr[base + (addr & 0x7FF)];
  }

  ppuWrite(addr, val) {
    if (!this.chrIsRAM || addr >= 0x2000) return;

    val &= 0xFF;

    const slot = addr >> 11;
    const base = this.chrMap[slot];

    this.chr[base + (addr & 0x7FF)] = val;
  }
}

class Mapper78 extends Mapper2 {} 
class Mapper85 extends Mapper24 {} // VRC7
class Mapper86 extends Mapper11 {}
class Mapper87 extends Mapper3 {}
class Mapper88 extends Mapper2 {}
class Mapper89 extends Mapper2 {}
class Mapper93 extends Mapper2 {}
class Mapper94 extends Mapper2 {}
class Mapper95 extends Mapper2 {}
class Mapper97 extends Mapper2 {}
class Mapper105 extends Mapper1 {}
class Mapper113 extends Mapper11 {}
class Mapper118 extends Mapper4 {} // TxSROM (MMC3 variant)
class Mapper119 extends Mapper4 {} // TQROM (MMC3 variant)
class Mapper152 extends IMapper {
  constructor(cart, bus) {
    super(cart, bus);

    // PRG: 16KB バンク切替 + 後半固定
    this.prgBanks16 = this.prg.length / 0x4000;
    this.prgBank = 0;

    // CHR: 8KB バンク切替
    this.chrBanks4 = this.chr.length / 0x1000;
this.chrBank0 = 0;
this.chrBank1 = 1;

  }

  cpuRead(addr) {
    if (addr < 0x6000) return 0;

    if (addr < 0x8000) {
      return this.prgRAM[addr - 0x6000];
    }

    // $8000-$BFFF : 切替バンク
    if (addr < 0xC000) {
      const base = (this.prgBank % this.prgBanks16) * 0x4000;
      return this.prg[base + (addr - 0x8000)];
    }

    // $C000-$FFFF : 最終バンク固定
    const base = (this.prgBanks16 - 1) * 0x4000;
    return this.prg[base + (addr - 0xC000)];
  }

  cpuWrite(addr, val) {
    val &= 0xff;

    if (addr >= 0x6000 && addr < 0x8000) {
      this.prgRAM[addr - 0x6000] = val;
      return;
    }

    if (addr >= 0x8000) {
  this.prgBank = val & 0x0f;

  // 4KB × 2
  this.chrBank0 = (val >> 4) & 0x0f;
  this.chrBank1 = ((val >> 4) & 0x0f) | 1;
}

  }

  ppuRead(addr) {
  if (addr < 0x1000) {
    const base = (this.chrBank0 % this.chrBanks4) * 0x1000;
    return this.chr[base + addr];
  }
  if (addr < 0x2000) {
    const base = (this.chrBank1 % this.chrBanks4) * 0x1000;
    return this.chr[base + (addr - 0x1000)];
  }
  return 0;
}


  ppuWrite(addr, val) {
    if (this.chrIsRAM && addr < 0x2000) {
      const base = (this.chrBank % this.chrBanks8) * 0x2000;
      this.chr[base + addr] = val & 0xff;
    }
  }
}

class Mapper180 extends Mapper2 {}
class Mapper184 extends Mapper3 {}
class Mapper185 extends Mapper3 {}
class Mapper206 extends Mapper2 {}


      class Cartridge {
        constructor(bytes) {
          this.bytes = bytes;
          this.valid = false;
          this.mapper = 0;
          this.submapper = 0;
          this.prg = null;
          this.chr = null;
          this.chrIsRAM = false;
          this.mirror = 0; // 0:H, 1:V
          this.battery = false;
          this.prgRAM = null; // 8KB default if absent (mapper may create)
          this.parse();
        }

        parse() {
          const b = this.bytes;
          if (
            !(b[0] === 0x4e && b[1] === 0x45 && b[2] === 0x53 && b[3] === 0x1a)
          )
            return;

          const prgLo = b[4],
            chrLo = b[5];
          const flag6 = b[6],
            flag7 = b[7];
          const hasTrainer = (flag6 & 0x04) !== 0;
          const fourScreen = (flag6 & 0x08) !== 0;
          this.battery = (flag6 & 0x02) !== 0;

          const nes2 = (flag7 & 0x0c) === 0x08;

          // Mapper (lower 8 bits)
          let mapper = (flag6 >> 4) | (flag7 & 0xf0);

          // NES 2.0: extend mapper/submapper and sizes
          let prgUnits16K = prgLo;
          let chrUnits8K = chrLo;
          if (nes2) {
            this.submapper = (b[8] >> 4) & 0x0f;
            mapper |= (b[8] & 0x0f) << 8; // upper 4 bits

            // Upper 4 bits of PRG/CHR size
            prgUnits16K |= (b[9] & 0x0f) << 8;
            chrUnits8K |= (b[9] & 0xf0) << 4;

            // 可変サイズ方式（拡張指数エンコード）は 0x0F 特殊値の時に b[9]/b[10] を使うが、
            // まずは12-bit通常値に対応すれば大半のROMが読める
          }

          // Mirroring (four-screen優先)
          if (fourScreen) {
            // 2: four-screen（あなたのBusがH/Vのみなら、とりあえずH固定にするか、
            // ここではHに落とす。後で4画面対応を入れてもOK）
            this.mirror = 0;
          } else {
            this.mirror = flag6 & 0x01; // 0:H, 1:V
          }

          this.mapper = mapper;

          // Offset after header (+trainer)
          let offset = 16;
          if (hasTrainer) offset += 512;

          // Sizes
          const prgSize = prgUnits16K * 16_384;
          const chrSize = chrUnits8K * 8_192;

          // Slices
          this.prg = b.slice(offset, offset + prgSize);
          offset += prgSize;

          if (chrSize === 0) {
            // CHR-RAM 8KB
            this.chr = new Uint8Array(0x2000);
            this.chrIsRAM = true;
          } else {
            this.chr = b.slice(offset, offset + chrSize);
            this.chrIsRAM = false;
            offset += chrSize;
          }

          // 任意: NES 2.0 の PRG-RAM/PRG-NVRAM/CHR-RAM サイズ（byte 10/11）を読む。
          // ひとまず mapper 側で 8KB を用意する実装でも動く。
          // After Cartridge.parse or after load

          // デバッグ: 切り出し確認
          

          // サポートマッパの判定
          this.valid = Object.keys(MapperRegistry).map(Number).includes(this.mapper);

          this.valid = true;
           }
      }

class PPURegisters {
  constructor() {
    this.PPUCTRL = 0;
    this.PPUMASK = 0;
    this.PPUSTATUS = 0xa0;
    this.OAMADDR = 0;

    // スクロール関連レジスタ
    this.v = 0;      // 現在のVRAMアドレス (15ビット)
    this.t = 0;      // 一時VRAMアドレス (15ビット)
    this.x = 0;      // Fine X スクロール (3ビット)
    this.w = 0;      // 書き込みトグル (0 or 1)
    
    // PPUDATAバッファ
    this.readBuffer = 0;
  }

  setSprite0Hit() {
    this.PPUSTATUS |= 0x40;
  }

  setVBlank(on) {
    if (on) this.PPUSTATUS |= 0x80;
    else this.PPUSTATUS &= ~0x80;
  }
}

class BackgroundUnit {
  constructor(ppu) {
    this.ppu = ppu;

    // シフトレジスタ (16ビット幅)
    this.patternLo = 0;
    this.patternHi = 0;
    this.attrLo = 0;
    this.attrHi = 0;

    // 次のタイルデータ (ラッチ)
    this.nextTileIndex = 0;
    this.nextTileAttr = 0;
    this.nextTileLo = 0;
    this.nextTileHi = 0;
  }

  step() {
    const { timing, reg } = this.ppu;
    const { scanline, cycle } = timing;

    const isRenderLine = scanline < 240 || scanline === 261;

    if (!isRenderLine) return;
const isVisibleLine = scanline < 240;
const isPreRenderLine = scanline === 261;

    // レンダリングが有効かチェック
    const renderingEnabled = (reg.PPUMASK & 0x18) !== 0;
    
   //if (!renderingEnabled) return;


    // Visible + prefetch cycles
    const isFetchCycle = (cycle >= 1 && cycle <= 256) || (cycle >= 321 && cycle <= 336);
   if (cycle >= 1 && cycle <= 256 || cycle >= 321 && cycle <= 336) {
      this.patternLo <<= 1;
      this.patternHi <<= 1;
      this.attrLo <<= 1;
      this.attrHi <<= 1;
    }
if (renderingEnabled && (isVisibleLine || isPreRenderLine)) {
    // visible + prefetch
    if (
      (scanline < 240 || scanline === 261) &&
      ((cycle >= 1 && cycle <= 256) || (cycle >= 321 && cycle <= 336))
    ) {
      // fetch処理
if (isFetchCycle) {

      // タイル境界でフェッチ・ロード
      const cycleMod8 = cycle % 8;
      
      switch (cycleMod8) {
        case 1: // Nametable fetch
          this.fetchNametable();
          break;
        case 3: // Attribute fetch
          this.fetchAttribute();
          break;
        case 5: // Pattern low fetch
          this.fetchPatternLow();
          break;
        case 7: // Pattern high fetch
          this.fetchPatternHigh();
          break;
          case 0: // Reload shift registers
          this.reloadShiftRegisters();
          this.incrementX();
          break;
       
      }
    }
    }
  }
    

    // シフトレジスタを左シフト (描画サイクル中)
    // cycle 1 で描画が始まるので、cycle 2-257 の間にシフト
    

    // Copy horizontal bits at cycle 257
    if (cycle === 257) {
      this.copyX();
    }

    // Increment Y at cycle 256
    if (cycle === 256) {
      this.incrementY();
    }

    // Copy vertical bits (pre-render line only)
    if (scanline === 261 && cycle >= 280 && cycle <= 304) {
      this.copyY();
    }
  }
  fetchNametable() {
    const v = this.ppu.reg.v;
    const ntAddr = 0x2000 | (v & 0x0FFF);
    this.nextTileIndex = this.ppu.ppuRead(ntAddr);
  }

  fetchAttribute() {
    const v = this.ppu.reg.v;
    const coarseX = v & 0x1F;
    const coarseY = (v >> 5) & 0x1F;
    
    const attrAddr = 0x23C0 | (v & 0x0C00) | ((coarseY >> 2) << 3) | (coarseX >> 2);
    const attr = this.ppu.ppuRead(attrAddr);
    
    // 2x2タイルブロック内の位置で2ビット選択
    const shift = ((coarseY & 2) << 1) | (coarseX & 2);
    this.nextTileAttr = (attr >> shift) & 0x03;
  }

  fetchPatternLow() {
    const { reg } = this.ppu;
    const fineY = (reg.v >> 12) & 0x7;
    const base = (reg.PPUCTRL & 0x10) ? 0x1000 : 0x0000;
    const addr = base + this.nextTileIndex * 16 + fineY;
    this.nextTileLo = this.ppu.ppuRead(addr);
  }

  fetchPatternHigh() {
    const { reg } = this.ppu;
    const fineY = (reg.v >> 12) & 0x7;
    const base = (reg.PPUCTRL & 0x10) ? 0x1000 : 0x0000;
    const addr = base + this.nextTileIndex * 16 + fineY + 8;
    this.nextTileHi = this.ppu.ppuRead(addr);
  }
reloadShiftRegisters() {
  this.patternLo = (this.patternLo & 0xFF00) | this.nextTileLo;
  this.patternHi = (this.patternHi & 0xFF00) | this.nextTileHi;

  // ★ これが抜けている
  const attr = this.nextTileAttr;
  this.attrLo = (this.attrLo & 0xFF00) | ((attr & 1) ? 0xFF : 0x00);
  this.attrHi = (this.attrHi & 0xFF00) | ((attr & 2) ? 0xFF : 0x00);
}



  incrementX() {
    const reg = this.ppu.reg;
    if ((reg.PPUMASK & 0x18) === 0) return;
    
    // Coarse X をインクリメント
    if ((reg.v & 0x001F) === 31) {
      reg.v &= ~0x001F;          // Coarse X = 0
      reg.v ^= 0x0400;            // Nametable 水平切り替え
    } else {
      reg.v++;
    }
  }

  incrementY() {
    const reg = this.ppu.reg;
    if ((reg.PPUMASK & 0x18) === 0) return;
    
    // Fine Y をインクリメント
    if ((reg.v & 0x7000) !== 0x7000) {
      reg.v += 0x1000;
    } else {
      reg.v &= ~0x7000;           // Fine Y = 0
      let y = (reg.v & 0x03E0) >> 5;
      
      if (y === 29) {
        y = 0;
        reg.v ^= 0x0800;          // Nametable 垂直切り替え
      } else if (y === 31) {
        y = 0;
      } else {
        y++;
      }
      reg.v = (reg.v & ~0x03E0) | (y << 5);
    }
  }

  copyX() {
    const reg = this.ppu.reg;
    if ((reg.PPUMASK & 0x18) === 0) return;
    
    // t の水平ビットを v にコピー
    reg.v = (reg.v & 0xFBE0) | (reg.t & 0x041F);
  }

  copyY() {
    const reg = this.ppu.reg;
    if ((reg.PPUMASK & 0x18) === 0) return;
    
    // t の垂直ビットを v にコピー
    reg.v = (reg.v & 0x841F) | (reg.t & 0x7BE0);
  }


  pixel(x,scanline) {
   
const fineX = this.ppu.reg.x;

  //const bit = 15 + fineX;
// 描画は常に MSB
const bit = 15-fineX;
 const lo = (this.patternLo >> bit) & 1;
  const hi = (this.patternHi >> bit) & 1;
  const attrLo = (this.attrLo >> bit) & 1;
  const attrHi = (this.attrHi >> bit) & 1;

  const paletteIndex = (hi << 1) | lo;
  const paletteGroup = (attrHi << 1) | attrLo;
    
    // 背景パレット: 0x00 (universal bg), 0x01-0x03, 0x05-0x07, ...
    const colorIndex = paletteIndex === 0 ? 0 : (paletteGroup * 4 + paletteIndex);
    
    return {
      color: colorIndex,
      nonZero: paletteIndex !== 0
    };
  }
}

class SpriteUnit {
  constructor(ppu) {
    this.ppu = ppu;
    this.secondaryOAM = [];
    this.sprites = []; // 描画用スプライトデータ
  }

  step(scanline, cycle) {
    // Sprite evaluation (cycle 0-64: clear, 65-256: evaluation)
    if (cycle === 1 && scanline < 240) {
      this.evaluate(scanline);
    }
    
    // Sprite fetch (cycle 257-320)
    if (cycle === 257 && scanline < 240) {
      this.fetchSprites(scanline);
    }
  }

  evaluate(scanline) {
    this.secondaryOAM = [];
    const spriteHeight = (this.ppu.reg.PPUCTRL & 0x20) ? 16 : 8;
    
    for (let i = 0; i < 64; i++) {
      const y = this.ppu.oam[i * 4];
      
      // Y座標は次のスキャンラインから有効
      if (scanline >= y && scanline < y + spriteHeight) {
        this.secondaryOAM.push({
          index: i,
          y: y,
          tile: this.ppu.oam[i * 4 + 1],
          attr: this.ppu.oam[i * 4 + 2],
          x: this.ppu.oam[i * 4 + 3]-1
        });
        
        if (this.secondaryOAM.length >= 8) {
          this.ppu.reg.PPUSTATUS |= 0x20; // Sprite overflow
          break;
        }
      }
    }
  }

  fetchSprites(scanline) {
    this.sprites = [];
    const spriteHeight = (this.ppu.reg.PPUCTRL & 0x20) ? 16 : 8;
    
    for (const spr of this.secondaryOAM) {
      let row = scanline - spr.y;
      
      // 垂直反転
      if (spr.attr & 0x80) {
        row = spriteHeight - 1 - row;
      }
      
      let patternAddr;
      if (spriteHeight === 8) {
        // 8x8 スプライト
        const base = (this.ppu.reg.PPUCTRL & 0x08) ? 0x1000 : 0x0000;
        patternAddr = base + spr.tile * 16 + row;
      } else {
        // 8x16 スプライト
        const bank = (spr.tile & 1) ? 0x1000 : 0x0000;
        const tile = spr.tile & 0xFE;
        const subtile = row >= 8 ? 1 : 0;
        patternAddr = bank + (tile + subtile) * 16 + (row & 7);
      }
      
      const lo = this.ppu.ppuRead(patternAddr);
      const hi = this.ppu.ppuRead(patternAddr + 8);
      
      this.sprites.push({
        index: spr.index,
        x: spr.x,
        attr: spr.attr,
        patternLo: lo,
        patternHi: hi
      });
    }
  }

  pixel(x) {
    for (const spr of this.sprites) {
      const offset = x - spr.x;
      if (offset < 0 || offset >= 8) continue;
      
      // 水平反転
      const bit = (spr.attr & 0x40) ? offset : (7 - offset);
      const lo = (spr.patternLo >> bit) & 1;
      const hi = (spr.patternHi >> bit) & 1;
      const paletteIndex = (hi << 1) | lo;
      
      if (paletteIndex === 0) continue; // 透明
      
      const paletteGroup = (spr.attr & 0x03) + 4; // スプライトパレット 4-7
      const colorIndex = paletteGroup * 4 + paletteIndex;
      
      return {
        visible: true,
        color: colorIndex,
        behind: (spr.attr & 0x20) !== 0,
        index: spr.index
      };
    }
    
    return { visible: false };
  }
}

class PPUTiming {
  constructor() {
    this.cycle = 0;
    this.scanline = 0;
    this.frame = 0;
    this.frameReady = false;
  }

  step(reg, bus) {
   
    if (this.scanline === 241 && this.cycle === 1) {
    reg.setVBlank(true);
        if (reg.PPUCTRL & 0x80) bus.requestNMI();
  }

 

  if (this.scanline === 261 && this.cycle === 1) {
    reg.setVBlank(false);
    reg.PPUSTATUS &= ~0x40;
    reg.PPUSTATUS &= ~0x20;
  }

  // ---- advance cycle ----
  this.cycle++;

  if (this.cycle > 340) {
    this.cycle = 0;
    this.scanline++;

    if (this.scanline > 261) {
      this.scanline = 0;
      this.frame++;
      this.frameReady = true;
    }
  }
  
  }

  isVisiblePixel() {
    return this.scanline < 240 && this.cycle >= 1 && this.cycle <= 256;
  }

  isVisibleScanline() {
    return this.scanline < 240;
  }

  inVBlank() {
    return this.scanline >= 241 && this.scanline <= 260;
  }

  consumeFrameFlag() {
    const f = this.frameReady;
    this.frameReady = false;
    return f;
  }
}

class PPU {
  constructor(bus) {
    this.bus = bus;
    this.oam = new Uint8Array(256);
    this.reg = new PPURegisters();
    this.timing = new PPUTiming();
    this.bg = new BackgroundUnit(this);
    this.sprite = new SpriteUnit(this);
    this.vram = new Uint8Array(0x800);
    this.pal = new Uint8Array(32);
    this.framebuffer = new Uint32Array(256 * 240);
  }

  reset() {
    // レジスタリセット時に v と t を同期
    this.reg.v = 0;
    this.reg.t = 0;
    this.reg.x = 0;
    this.reg.w = 0;
  }

  consumeFrameFlag() {
    return this.timing.consumeFrameFlag();
  }


  cpuWrite(addr, value) {
    switch (addr & 0x7) {
      case 0: // PPUCTRL ($2000)
        this.reg.PPUCTRL = value;
        // t の nametable ビット更新
        this.reg.t = (this.reg.t & 0xF3FF) | ((value & 0x03) << 10);
        break;
        
      case 1: // PPUMASK ($2001)
        this.reg.PPUMASK = value;
        break;
        
      case 3: // OAMADDR ($2003)
        this.reg.OAMADDR = value;
        break;
        
      case 4: // OAMDATA ($2004)
        this.oam[this.reg.OAMADDR] = value;
        this.reg.OAMADDR = (this.reg.OAMADDR + 1) & 0xFF;
        break;
        
      case 5: // PPUSCROLL ($2005)
        if (this.reg.w === 0) {
          // 1回目: X スクロール
          this.reg.t = (this.reg.t & 0xFFE0) | (value >> 3);
          this.reg.x = value & 0x07;
          this.reg.w = 1;
        } else {
          // 2回目: Y スクロール
          this.reg.t = (this.reg.t & 0x8C1F) | ((value & 0xF8) << 2) | ((value & 0x07) << 12);
          this.reg.w = 0;
        }
        break;
        
      case 6: // PPUADDR ($2006)
        if (this.reg.w === 0) {
          // 1回目: 上位バイト
          this.reg.t = (this.reg.t & 0x00FF) | ((value & 0x3F) << 8);
          this.reg.w = 1;
        } else {
          // 2回目: 下位バイト
          this.reg.t = (this.reg.t & 0xFF00) | value;
          this.reg.v = this.reg.t;
          this.reg.w = 0;
        }
        break;
        
      case 7: // PPUDATA ($2007)
        this.ppuWrite(this.reg.v, value);
        const inc = (this.reg.PPUCTRL & 0x04) ? 32 : 1;
        this.reg.v = (this.reg.v + inc) & 0x7FFF;
        break;
    }
  }

  cpuRead(addr) {
    switch (addr & 0x7) {
      case 2: { // PPUSTATUS ($2002)
        const status = this.reg.PPUSTATUS;
        this.reg.PPUSTATUS &= 0x7F; // VBlank フラグクリア
        this.reg.w = 0;              // 書き込みトグルリセット
        return status;
      }
      case 4: // OAMDATA ($2004)
        return this.oam[this.reg.OAMADDR];
        
      case 7: { // PPUDATA ($2007)
        let data = this.ppuRead(this.reg.v);
        
        // パレットRAM以外はバッファリング
        if ((this.reg.v & 0x3FFF) < 0x3F00) {
          const buffered = this.reg.readBuffer;
          this.reg.readBuffer = data;
          data = buffered;
        } else {
          // パレットは即座に読み出し (下位のVRAMはバッファに)
          this.reg.readBuffer = this.ppuRead(this.reg.v - 0x1000);
        }
        
        const inc = (this.reg.PPUCTRL & 0x04) ? 32 : 1;
        this.reg.v = (this.reg.v + inc) & 0x7FFF;
        return data;
      }
    }
    return 0;
  }

  ppuRead(addr) {
    addr &= 0x3FFF;
    
    if (addr < 0x2000) {
      return this.bus.cartCHRRead(addr);
    } else if (addr < 0x3F00) {
      const nt = this.bus.ntMirror(addr);
      return this.vram[nt];
    } else if (addr < 0x4000) {
      let i = addr & 0x1F;
      // パレットミラーリング ($10/$14/$18/$1C -> $00/$04/$08/$0C)
      if ((i & 0x13) === 0x10) i &= ~0x10;
      return this.pal[i];
    }
    return 0;
  }

  ppuWrite(addr, val) {
    addr &= 0x3FFF;
    val &= 0xFF;
    
    if (addr < 0x2000) {
      this.bus.cartCHRWrite(addr, val);
    } else if (addr < 0x3F00) {
      const nt = this.bus.ntMirror(addr);
      this.vram[nt] = val;
    } else if (addr < 0x4000) {
      let i = addr & 0x1F;
      if ((i & 0x13) === 0x10) i &= ~0x10;
      this.pal[i] = val;
    }
  }

  step() {
    
    const { scanline, cycle } = this.timing;
    this.bg.step();
    this.sprite.step(scanline, cycle);
    // Visible pixel rendering
    if (this.timing.isVisiblePixel()) {
       const x = cycle - 1;
      const bg = this.bg.pixel(x,scanline);
      const spr = this.sprite.pixel(x,scanline);
      let colorIndex = 0; // Default: universal background color
      
      // レンダリング無効時は背景色のみ
      if ((this.reg.PPUMASK & 0x18) === 0) {
        colorIndex = 0;
      } else {
        // 優先順位: スプライト(前) > 背景 > スプライト(後) > 背景色
        if (spr.visible && !spr.behind) {
          colorIndex = spr.color;
          // Sprite 0 hit 判定
         

          if (spr.index === 0 && bg.nonZero && x !== 255) {
            this.reg.setSprite0Hit();
          }
        } else if (bg.nonZero) {
          colorIndex = bg.color;
        } else if (spr.visible) {
          colorIndex = spr.color;
        }
      }

      // パレットから実際の色を取得
      const paletteColor = this.pal[colorIndex];
      this.framebuffer[scanline * 256 + x] = NES_PALETTE[paletteColor & 0x3F];
    }
 this.timing.step(this.reg, this.bus);
    
   
  }
}



class CPU {
  constructor(bus) {
    this.bus = bus;
    // Registers
    this.A = 0;
    this.X = 0;
    this.Y = 0;
    this.S = 0xfd; // Stack pointer
    this.P = 0x24; // NV-BDIZC (power-up: 0x24 typical)
    this.PC = 0x0000;
    this.cycles = 0;
    this.pendingNMI = false;
    this.pendingIRQ = false;
    this.opcodes = this.buildOpcodeTable();
    this.cycTable = new Uint8Array([
      /*0x00*/ 7,6,2,8,3,3,5,5,3,2,2,2,4,4,6,6,
      /*0x10*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,
      /*0x20*/ 6,6,2,8,3,3,5,5,4,2,2,2,4,4,6,6,
      /*0x30*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,
      /*0x40*/ 6,6,2,8,3,3,5,5,3,2,2,2,3,4,6,6,
      /*0x50*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,
      /*0x60*/ 6,6,2,8,3,3,5,5,4,2,2,2,5,4,6,6,
      /*0x70*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,
      /*0x80*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,
      /*0x90*/ 2,6,2,6,4,4,4,4,2,5,2,5,5,5,5,5,
      /*0xA0*/ 2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,
      /*0xB0*/ 2,5,2,5,4,4,4,4,2,4,2,4,4,4,4,4,
      /*0xC0*/ 2,6,2,8,3,3,5,5,2,2,2,2,4,4,6,6,
      /*0xD0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,
      /*0xE0*/ 2,6,3,8,3,3,5,5,2,2,2,2,4,4,6,6,
      /*0xF0*/ 2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7
    ]);
  }

  reset() {
  const lo = this.bus.cpuRead(0xFFFC);
  const hi = this.bus.cpuRead(0xFFFD);
  this.PC = lo | (hi << 8);

  this.A = 0;
  this.X = 0;
  this.Y = 0;
  this.S = 0xFD;
 
this.P = 0x34;
  this.cycles = 7;
  this.pendingNMI = false;
  this.pendingIRQ = false;

  
}


  // Flags
  updateZN(v) {
    this.P = (this.P & ~0x82) | ((v === 0 ? 0x02 : 0) | (v & 0x80));
  }
  setZ(v) {
    this.P = (this.P & ~0x02) | (v === 0 ? 0x02 : 0);
  }
  setN(v) {
    this.P = (this.P & ~0x80) | (v & 0x80);
  }
  get I() {
    return (this.P >> 2) & 1;
  }
  setC(b) {
    this.P = (this.P & ~0x01) | (b ? 1 : 0);
  }
  setV(b) {
    this.P = (this.P & ~0x40) | (b ? 0x40 : 0);
  }
  setD(b) {
    this.P = (this.P & ~0x08) | (b ? 0x08 : 0);
  }
  setI(b) {
    this.P = (this.P & ~0x04) | (b ? 0x04 : 0);
  }

  // Memory helpers
  read(addr) {
    return this.bus.cpuRead(addr);
  }
  write(addr, v) {
    this.bus.cpuWrite(addr, v);
  }
  read16(addr) {
    const lo = this.read(addr);
    const hi = this.read((addr + 1) & 0xffff);
    return (hi << 8) | lo;
  }
  read16bug(addr) {
    const lo = this.read(addr);
    const a2 = (addr & 0xff00) | ((addr + 1) & 0xff);
    const hi = this.read(a2);
    return (hi << 8) | lo;
  }

  // Stack
  push(v) {
    this.write(0x0100 | this.S, v);
    this.S = (this.S - 1) & 0xff;
  }
  pull() {
    this.S = (this.S + 1) & 0xff;
    return this.read(0x0100 | this.S);
  }

  // Interrupts
  nmi() {
    this.push((this.PC >> 8) & 0xff);
    this.push(this.PC & 0xff);
    this.push(this.P & ~0x10);
    this.setI(1);
    this.PC = this.read16(0xfffa);
    this.cycles += 7;
  }
  irq() {
    if (!this.I) {
      this.push((this.PC >> 8) & 0xff);
      this.push(this.PC & 0xff);
      this.push(this.P & ~0x10);
      this.setI(1);
      this.PC = this.read16(0xfffe);
      this.cycles += 7;
    }
  }

  adc(m) {
    const a = this.A, c = this.P & 1;
    const r = a + m + c;
    this.setC(r > 0xff);
    const res = r & 0xff;
    this.setV((~(a ^ m) & (a ^ res) & 0x80) !== 0);
    this.A = res;
    this.updateZN(res);
  }

  sbc(m) {
    const a = this.A, c = this.P & 1;
    const m2 = ~m & 0xff;
    const r = a + m2 + c;
    this.setC(r > 0xff);
    const res = r & 0xff;
    this.setV((~(a ^ m2) & (a ^ res) & 0x80) !== 0);
    this.A = res;
    this.updateZN(res);
  }

  compare(reg, m) {
    const r = (reg - m) & 0x1ff;
    this.setC(reg >= m);
    this.updateZN(r & 0xff);
  }

  // Addressing modes
  fetch() {
    const v = this.read(this.PC);
    this.PC = (this.PC + 1) & 0xffff;
    return v;
  }
  
  addr_imm() {
    return this.PC++;
  }
  addr_zp() {
    return this.fetch();
  }
  addr_zpx() {
    return (this.fetch() + this.X) & 0xff;
  }
  addr_zpy() {
    return (this.fetch() + this.Y) & 0xff;
  }
  addr_abs() {
    const lo = this.fetch();
    const hi = this.fetch();
    return (hi << 8) | lo;
  }
  addr_abx(extraCycle = false) {
    const lo = this.fetch();
    const hi = this.fetch();
    const base = (hi << 8) | lo;
    const addr = (base + this.X) & 0xffff;
    // ページクロス検出
    if (extraCycle && (base & 0xff00) !== (addr & 0xff00)) {
      this.cycles++;
    }
    return addr;
  }
  addr_aby(extraCycle = false) {
    const lo = this.fetch();
    const hi = this.fetch();
    const base = (hi << 8) | lo;
    const addr = (base + this.Y) & 0xffff;
    // ページクロス検出
    if (extraCycle && (base & 0xff00) !== (addr & 0xff00)) {
      this.cycles++;
    }
    return addr;
  }
  addr_ind() {
    const a = this.addr_abs();
    return this.read16bug(a);
  }
  addr_izx() {
    const zp = (this.fetch() + this.X) & 0xff;
    const lo = this.read(zp);
    const hi = this.read((zp + 1) & 0xff);
    return (hi << 8) | lo;
  }
  addr_izy(extraCycle = false) {
    const zp = this.fetch();
    const lo = this.read(zp);
    const hi = this.read((zp + 1) & 0xff);
    const base = (hi << 8) | lo;
    const addr = (base + this.Y) & 0xffff;
    // ページクロス検出
    if (extraCycle && (base & 0xff00) !== (addr & 0xff00)) {
      this.cycles++;
    }
    return addr;
  }
  
  rel() {
    let o = this.fetch();
    if (o & 0x80) o = o - 0x100;
    return o;
  }

  // One CPU step = execute one opcode
  step() {
 
 const before = this.cycles;

    // Handle pending interrupts
   // CPU.step() の最初あたり

 

if (this.bus.takeNMI()) {
      this.nmi();
      return 7; // NMI自体のサイクル
    }
    if (this.bus.takeIRQ() && !this.I) {
      this.irq();
      return 7; // IRQ自体のサイクル
    }

    const op = this.fetch();
    const entry = this.opcodes[op];
    if (!entry) {
      throw new Error(
        `Unimplemented opcode $${op.toString(16).padStart(2, "0")} at PC=${(this.PC - 1).toString(16)}`
      );
    }
    // CPU実行ループ中


    const cycleBefore = this.cycles;
    entry.call(this);
     
    // cycTable からベースサイクルを加算（命令内で追加サイクルが加算済み）
    const used = this.cycTable[op];
  this.cycles += used;

  return used; // ← ここが超重要
  }

  buildOpcodeTable() {
    const t = new Array(256);

    // RMW helpers
    const ASL = (v) => {
      const c = (v >> 7) & 1;
      const r = (v << 1) & 0xff;
      this.setC(c);
      this.updateZN(r);
      return r;
    };
    const LSR = (v) => {
      const c = v & 1;
      const r = (v >>> 1) & 0xff;
      this.setC(c);
      this.updateZN(r);
      return r;
    };
    const ROL = (v) => {
      const cIn = this.P & 1;
      const cOut = (v >> 7) & 1;
      const r = ((v << 1) & 0xff) | cIn;
      this.setC(cOut);
      this.updateZN(r);
      return r;
    };
    const ROR = (v) => {
      const cIn = this.P & 1;
      const cOut = v & 1;
      const r = ((v >>> 1) | (cIn << 7)) & 0xff;
      this.setC(cOut);
      this.updateZN(r);
      return r;
    };
    const BR = (cond) => {
      const offRaw = this.read(this.PC++); 
  // 1. 符号拡張を行う
  const off = (offRaw & 0x80) ? (offRaw - 256) : offRaw;

  if (cond) {
    const base = this.PC; 
    const dest = (base + off) & 0xffff;

    // 2. ページ跨ぎ判定（オプションだが正確さのために）
    if ((base & 0xff00) !== (dest & 0xff00)) {
      this.cycles++;
    }
    
    this.PC = dest;
    this.cycles++; // 分岐成立による追加
  }
};

    // Branch helper
   


    // BIT instruction
    const BIT = (m) => {
      const v = m & 0xff;
      this.P = (this.P & ~0x02) | ((this.A & v) === 0 ? 0x02 : 0x00);
      this.P = (this.P & ~0x40) | (v & 0x40);
      this.P = (this.P & ~0x80) | (v & 0x80);
    };

    // Load/Store operations
    const LDA = (m) => { this.A = m & 0xff; this.updateZN(this.A); };
    const LDX = (m) => { this.X = m & 0xff; this.updateZN(this.X); };
    const LDY = (m) => { this.Y = m & 0xff; this.updateZN(this.Y); };
    const STA = (addr) => { this.write(addr, this.A); };
    const STX = (addr) => { this.write(addr, this.X); };
    const STY = (addr) => { this.write(addr, this.Y); };

    // Logic operations
    const ORA = (m) => { this.A = (this.A | m) & 0xff; this.updateZN(this.A); };
    const AND = (m) => { this.A = (this.A & m) & 0xff; this.updateZN(this.A); };
    const EOR = (m) => { this.A = (this.A ^ m) & 0xff; this.updateZN(this.A); };

    // INC/DEC
    const INC = (v) => { const r = (v + 1) & 0xff; this.updateZN(r); return r; };
    const DEC = (v) => { const r = (v - 1) & 0xff; this.updateZN(r); return r; };

    // === LDA ===
    t[0xa9] = function() { LDA.call(this, this.read(this.addr_imm())); };
    t[0xa5] = function() { LDA.call(this, this.read(this.addr_zp())); };
    t[0xb5] = function() { LDA.call(this, this.read(this.addr_zpx())); };
    t[0xad] = function() { LDA.call(this, this.read(this.addr_abs())); };
    t[0xbd] = function() { LDA.call(this, this.read(this.addr_abx(true))); };
    t[0xb9] = function() { LDA.call(this, this.read(this.addr_aby(true))); };
    t[0xa1] = function() { LDA.call(this, this.read(this.addr_izx())); };
    t[0xb1] = function() { LDA.call(this, this.read(this.addr_izy(true))); };

    // === LDX ===
    t[0xa2] = function() { LDX.call(this, this.read(this.addr_imm())); };
    t[0xa6] = function() { LDX.call(this, this.read(this.addr_zp())); };
    t[0xb6] = function() { LDX.call(this, this.read(this.addr_zpy())); };
    t[0xae] = function() { LDX.call(this, this.read(this.addr_abs())); };
    t[0xbe] = function() { LDX.call(this, this.read(this.addr_aby(true))); };

    // === LDY ===
    t[0xa0] = function() { LDY.call(this, this.read(this.addr_imm())); };
    t[0xa4] = function() { LDY.call(this, this.read(this.addr_zp())); };
    t[0xb4] = function() { LDY.call(this, this.read(this.addr_zpx())); };
    t[0xac] = function() { LDY.call(this, this.read(this.addr_abs())); };
    t[0xbc] = function() { LDY.call(this, this.read(this.addr_abx(true))); };

    // === STA ===
    t[0x85] = function() { STA.call(this, this.addr_zp()); };
    t[0x95] = function() { STA.call(this, this.addr_zpx()); };
    t[0x8d] = function() { STA.call(this, this.addr_abs()); };
    t[0x9d] = function() { STA.call(this, this.addr_abx()); };
    t[0x99] = function() { STA.call(this, this.addr_aby()); };
    t[0x81] = function() { STA.call(this, this.addr_izx()); };
    t[0x91] = function() { STA.call(this, this.addr_izy()); };

    // === STX ===
    t[0x86] = function() { STX.call(this, this.addr_zp()); };
    t[0x96] = function() { STX.call(this, this.addr_zpy()); };
    t[0x8e] = function() { STX.call(this, this.addr_abs()); };

    // === STY ===
    t[0x84] = function() { STY.call(this, this.addr_zp()); };
    t[0x94] = function() { STY.call(this, this.addr_zpx()); };
    t[0x8c] = function() { STY.call(this, this.addr_abs()); };

    // === ORA ===
    t[0x09] = function() { ORA.call(this, this.read(this.addr_imm())); };
    t[0x05] = function() { ORA.call(this, this.read(this.addr_zp())); };
    t[0x15] = function() { ORA.call(this, this.read(this.addr_zpx())); };
    t[0x0d] = function() { ORA.call(this, this.read(this.addr_abs())); };
    t[0x1d] = function() { ORA.call(this, this.read(this.addr_abx(true))); };
    t[0x19] = function() { ORA.call(this, this.read(this.addr_aby(true))); };
    t[0x01] = function() { ORA.call(this, this.read(this.addr_izx())); };
    t[0x11] = function() { ORA.call(this, this.read(this.addr_izy(true))); };

    // === AND ===
    t[0x29] = function() { AND.call(this, this.read(this.addr_imm())); };
    t[0x25] = function() { AND.call(this, this.read(this.addr_zp())); };
    t[0x35] = function() { AND.call(this, this.read(this.addr_zpx())); };
    t[0x2d] = function() { AND.call(this, this.read(this.addr_abs())); };
    t[0x3d] = function() { AND.call(this, this.read(this.addr_abx(true))); };
    t[0x39] = function() { AND.call(this, this.read(this.addr_aby(true))); };
    t[0x21] = function() { AND.call(this, this.read(this.addr_izx())); };
    t[0x31] = function() { AND.call(this, this.read(this.addr_izy(true))); };

    // === EOR ===
    t[0x49] = function() { EOR.call(this, this.read(this.addr_imm())); };
    t[0x45] = function() { EOR.call(this, this.read(this.addr_zp())); };
    t[0x55] = function() { EOR.call(this, this.read(this.addr_zpx())); };
    t[0x4d] = function() { EOR.call(this, this.read(this.addr_abs())); };
    t[0x5d] = function() { EOR.call(this, this.read(this.addr_abx(true))); };
    t[0x59] = function() { EOR.call(this, this.read(this.addr_aby(true))); };
    t[0x41] = function() { EOR.call(this, this.read(this.addr_izx())); };
    t[0x51] = function() { EOR.call(this, this.read(this.addr_izy(true))); };

    // === ADC ===
    t[0x69] = function() { this.adc(this.read(this.addr_imm())); };
    t[0x65] = function() { this.adc(this.read(this.addr_zp())); };
    t[0x75] = function() { this.adc(this.read(this.addr_zpx())); };
    t[0x6d] = function() { this.adc(this.read(this.addr_abs())); };
    t[0x7d] = function() { this.adc(this.read(this.addr_abx(true))); };
    t[0x79] = function() { this.adc(this.read(this.addr_aby(true))); };
    t[0x61] = function() { this.adc(this.read(this.addr_izx())); };
    t[0x71] = function() { this.adc(this.read(this.addr_izy(true))); };

    // === SBC ===
    t[0xe9] = function() { this.sbc(this.read(this.addr_imm())); };
    t[0xe5] = function() { this.sbc(this.read(this.addr_zp())); };
    t[0xf5] = function() { this.sbc(this.read(this.addr_zpx())); };
    t[0xed] = function() { this.sbc(this.read(this.addr_abs())); };
    t[0xfd] = function() { this.sbc(this.read(this.addr_abx(true))); };
    t[0xf9] = function() { this.sbc(this.read(this.addr_aby(true))); };
    t[0xe1] = function() { this.sbc(this.read(this.addr_izx())); };
    t[0xf1] = function() { this.sbc(this.read(this.addr_izy(true))); };

    // === BIT ===
    t[0x24] = function() { BIT.call(this, this.read(this.addr_zp())); };
    t[0x2c] = function() { BIT.call(this, this.read(this.addr_abs())); };

    // === CMP/CPX/CPY ===
    t[0xc9] = function() { this.compare(this.A, this.read(this.addr_imm())); };
    t[0xc5] = function() { this.compare(this.A, this.read(this.addr_zp())); };
    t[0xd5] = function() { this.compare(this.A, this.read(this.addr_zpx())); };
    t[0xcd] = function() { this.compare(this.A, this.read(this.addr_abs())); };
    t[0xdd] = function() { this.compare(this.A, this.read(this.addr_abx(true))); };
    t[0xd9] = function() { this.compare(this.A, this.read(this.addr_aby(true))); };
    t[0xc1] = function() { this.compare(this.A, this.read(this.addr_izx())); };
    t[0xd1] = function() { this.compare(this.A, this.read(this.addr_izy(true))); };

    t[0xe0] = function() { this.compare(this.X, this.read(this.addr_imm())); };
    t[0xe4] = function() { this.compare(this.X, this.read(this.addr_zp())); };
    t[0xec] = function() { this.compare(this.X, this.read(this.addr_abs())); };

    t[0xc0] = function() { this.compare(this.Y, this.read(this.addr_imm())); };
    t[0xc4] = function() { this.compare(this.Y, this.read(this.addr_zp())); };
    t[0xcc] = function() { this.compare(this.Y, this.read(this.addr_abs())); };

    // === INC (memory) ===
    t[0xe6] = function() { const a = this.addr_zp(); this.write(a, INC(this.read(a))); };
    t[0xf6] = function() { const a = this.addr_zpx(); this.write(a, INC(this.read(a))); };
    t[0xee] = function() { const a = this.addr_abs(); this.write(a, INC(this.read(a))); };
    t[0xfe] = function() { const a = this.addr_abx(); this.write(a, INC(this.read(a))); };

    // === DEC (memory) ===
    t[0xc6] = function() { const a = this.addr_zp(); this.write(a, DEC(this.read(a))); };
    t[0xd6] = function() { const a = this.addr_zpx(); this.write(a, DEC(this.read(a))); };
    t[0xce] = function() { const a = this.addr_abs(); this.write(a, DEC(this.read(a))); };
    t[0xde] = function() { const a = this.addr_abx(); this.write(a, DEC(this.read(a))); };

    // === INX/INY/DEX/DEY ===
    t[0xe8] = function() { this.X = (this.X + 1) & 0xff; this.updateZN(this.X); };
    t[0xc8] = function() { this.Y = (this.Y + 1) & 0xff; this.updateZN(this.Y); };
    t[0xca] = function() { this.X = (this.X - 1) & 0xff; this.updateZN(this.X); };
    t[0x88] = function() { this.Y = (this.Y - 1) & 0xff; this.updateZN(this.Y); };

    // === Shift/Rotate (Accumulator) ===
    t[0x0a] = function() { this.A = ASL(this.A); };
    t[0x4a] = function() { this.A = LSR(this.A); };
    t[0x2a] = function() { this.A = ROL(this.A); };
    t[0x6a] = function() { this.A = ROR(this.A); };

    // === ASL (memory) ===
    t[0x06] = function() { const a = this.addr_zp(); this.write(a, ASL(this.read(a))); };
    t[0x16] = function() { const a = this.addr_zpx(); this.write(a, ASL(this.read(a))); };
    t[0x0e] = function() { const a = this.addr_abs(); this.write(a, ASL(this.read(a))); };
    t[0x1e] = function() { const a = this.addr_abx(); this.write(a, ASL(this.read(a))); };

    // === LSR (memory) ===
    t[0x46] = function() { const a = this.addr_zp(); this.write(a, LSR(this.read(a))); };
    t[0x56] = function() { const a = this.addr_zpx(); this.write(a, LSR(this.read(a))); };
    t[0x4e] = function() { const a = this.addr_abs(); this.write(a, LSR(this.read(a))); };
    t[0x5e] = function() { const a = this.addr_abx(); this.write(a, LSR(this.read(a))); };

    // === ROL (memory) ===
    t[0x26] = function() { const a = this.addr_zp(); this.write(a, ROL(this.read(a))); };
    t[0x36] = function() { const a = this.addr_zpx(); this.write(a, ROL(this.read(a))); };
    t[0x2e] = function() { const a = this.addr_abs(); this.write(a, ROL(this.read(a))); };
    t[0x3e] = function() { const a = this.addr_abx(); this.write(a, ROL(this.read(a))); };

    // === ROR (memory) ===
    t[0x66] = function() { const a = this.addr_zp(); this.write(a, ROR(this.read(a))); };
    t[0x76] = function() { const a = this.addr_zpx(); this.write(a, ROR(this.read(a))); };
    t[0x6e] = function() { const a = this.addr_abs(); this.write(a, ROR(this.read(a))); };
    t[0x7e] = function() { const a = this.addr_abx(); this.write(a, ROR(this.read(a))); };

    // === Branches ===
    t[0x10] = function() { BR.call(this, (this.P & 0x80) === 0); }; // BPL
    t[0x30] = function() { BR.call(this, (this.P & 0x80) !== 0); }; // BMI
    t[0x50] = function() { BR.call(this, (this.P & 0x40) === 0); }; // BVC
    t[0x70] = function() { BR.call(this, (this.P & 0x40) !== 0); }; // BVS
    t[0x90] = function() { BR.call(this, (this.P & 0x01) === 0); }; // BCC
    t[0xb0] = function() { BR.call(this, (this.P & 0x01) !== 0); }; // BCS
    t[0xd0] = function() { BR.call(this, (this.P & 0x02) === 0); }; // BNE
    t[0xf0] = function() { BR.call(this, (this.P & 0x02) !== 0); }; // BEQ

    // === Jumps/Subroutines ===
    t[0x4c] = function() { this.PC = this.addr_abs(); }; // JMP abs
    t[0x6c] = function() { this.PC = this.addr_ind(); }; // JMP ind
    t[0x20] = function() { // JSR
      const a = this.addr_abs();
      const ret = (this.PC - 1) & 0xffff;
      this.push((ret >> 8) & 0xff);
      this.push(ret & 0xff);
      this.PC = a;
    };
    t[0x60] = function() { // RTS
      const lo = this.pull();
      const hi = this.pull();
      this.PC = (((hi << 8) | lo) + 1) & 0xffff;
    };
    t[0x40] = function() { // RTI
      this.P = (this.pull() | 0x20) & ~0x10;
      const lo = this.pull();
      const hi = this.pull();
      this.PC = (hi << 8) | lo;
    };

    // === Stack ===
    t[0x48] = function() { this.push(this.A); }; // PHA
    t[0x68] = function() { this.A = this.pull(); this.updateZN(this.A); }; // PLA
    t[0x08] = function() { this.push(this.P | 0x10); }; // PHP
    t[0x28] = function() { this.P = (this.pull() & ~0x10) | 0x20; }; // PLP

    // === Register Transfers ===
    t[0xaa] = function() { this.X = this.A; this.updateZN(this.X); }; // TAX
    t[0x8a] = function() { this.A = this.X; this.updateZN(this.A); }; // TXA
    t[0xa8] = function() { this.Y = this.A; this.updateZN(this.Y); }; // TAY
    t[0x98] = function() { this.A = this.Y; this.updateZN(this.A); }; // TYA
    t[0xba] = function() { this.X = this.S; this.updateZN(this.X); }; // TSX
    t[0x9a] = function() { this.S = this.X; }; // TXS

    // === Flag Instructions ===
    t[0x18] = function() { this.setC(0); }; // CLC
    t[0x38] = function() { this.setC(1); }; // SEC
    t[0x58] = function() { this.setI(0); }; // CLI
    t[0x78] = function() { this.setI(1); }; // SEI
    t[0xb8] = function() { this.setV(0); }; // CLV
    t[0xd8] = function() { this.setD(0); }; // CLD
    t[0xf8] = function() { this.setD(1); }; // SED
t[0x00] = function() {
  this.fetch(); // padding byte (PC already incremented)
  const pc = this.PC; // ← これが正解
  this.push((pc >> 8) & 0xff);
  this.push(pc & 0xff);
  this.push(this.P | 0x10);
  this.setI(1);
  this.PC = this.read16(0xfffe);
};

    // === NOP ===
    t[0xea] = function() { /* NOP */ };

    // Fill undefined opcodes with NOP
    for (let i = 0; i < 256; i++) {
      if (!t[i]) t[i] = function() { };
    }

    return t;
  }
}
// ========== APU Implementation ==========
      
      class Envelope {
        constructor() {
          this.start = false;
          this.divider = 0;
          this.decayLevel = 0;
          this.loop = false;
          this.constant = false;
          this.volume = 0;
        }
        
        clock() {
          if (this.start) {
            this.start = false;
            this.decayLevel = 15;
            this.divider = this.volume;
          } else {
            if (this.divider === 0) {
              this.divider = this.volume;
              if (this.decayLevel > 0) {
                this.decayLevel--;
              } else if (this.loop) {
                this.decayLevel = 15;
              }
            } else {
              this.divider--;
            }
          }
        }
        
        output() {
          return this.constant ? this.volume : this.decayLevel;
        }
      }
      
      class Sweep {
        constructor(channel) {
          this.channel = channel; // 1 for pulse1, 2 for pulse2
          this.enabled = false;
          this.period = 0;
          this.negate = false;
          this.shift = 0;
          this.reload = false;
          this.divider = 0;
        }
        
        clock(timer) {
          if (this.divider === 0 && this.enabled && this.shift > 0 && timer >= 8) {
            const change = timer >> this.shift;
            if (this.negate) {
              timer -= change;
              if (this.channel === 1) timer--; // Pulse 1 の補正
            } else {
              timer += change;
            }
          }
          
          if (this.divider === 0 || this.reload) {
            this.divider = this.period;
            this.reload = false;
          } else {
            this.divider--;
          }
          
          return timer;
        }
        
        mute(timer) {
          if (timer < 8) return true;
          if (!this.negate && ((timer + (timer >> this.shift)) > 0x7FF)) return true;
          return false;
        }
      }
      
      class LengthCounter {
        constructor() {
          this.counter = 0;
          this.halt = false;
        }
        
        clock() {
          if (this.counter > 0 && !this.halt) {
            this.counter--;
          }
        }
        
        load(value) {
          const table = [
            10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14,
            12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30
          ];
          this.counter = table[value];
        }
      }
      
      class Pulse {
        constructor(channel) {
          this.channel = channel;
          this.enabled = false;
          this.duty = 0;
          this.envelope = new Envelope();
          this.sweep = new Sweep(channel);
          this.lengthCounter = new LengthCounter();
          this.timer = 0;
          this.timerPeriod = 0;
          this.sequencePos = 0;
          
          this.dutyTable = [
            [0, 1, 0, 0, 0, 0, 0, 0], // 12.5%
            [0, 1, 1, 0, 0, 0, 0, 0], // 25%
            [0, 1, 1, 1, 1, 0, 0, 0], // 50%
            [1, 0, 0, 1, 1, 1, 1, 1]  // 25% negated
          ];
        }
        
        write(addr, value) {
          switch (addr & 3) {
            case 0: // $4000/$4004
              this.duty = (value >> 6) & 3;
              this.lengthCounter.halt = (value & 0x20) !== 0;
              this.envelope.loop = (value & 0x20) !== 0;
              this.envelope.constant = (value & 0x10) !== 0;
              this.envelope.volume = value & 0x0F;
              break;
            case 1: // $4001/$4005
              this.sweep.enabled = (value & 0x80) !== 0;
              this.sweep.period = (value >> 4) & 7;
              this.sweep.negate = (value & 0x08) !== 0;
              this.sweep.shift = value & 7;
              this.sweep.reload = true;
              break;
            case 2: // $4002/$4006
              this.timerPeriod = (this.timerPeriod & 0x700) | value;
              break;
            case 3: // $4003/$4007
              this.timerPeriod = (this.timerPeriod & 0xFF) | ((value & 7) << 8);
              this.lengthCounter.load((value >> 3) & 0x1F);
              this.envelope.start = true;
              this.sequencePos = 0;
              break;
          }
        }
        
        clockTimer() {
          if (this.timer === 0) {
            this.timer = this.timerPeriod;
            this.sequencePos = (this.sequencePos + 1) & 7;
          } else {
            this.timer--;
          }
        }
        
        clockEnvelope() {
          this.envelope.clock();
        }
        
        clockSweep() {
          this.timerPeriod = this.sweep.clock(this.timerPeriod);
        }
        
        clockLength() {
          this.lengthCounter.clock();
        }
        
        output() {
          if (!this.enabled) return 0;
          if (this.lengthCounter.counter === 0) return 0;
          if (this.sweep.mute(this.timerPeriod)) return 0;
          if (this.dutyTable[this.duty][this.sequencePos] === 0) return 0;
          return this.envelope.output();
        }
      }
      
      class Triangle {
        constructor() {
          this.enabled = false;
          this.lengthCounter = new LengthCounter();
          this.linearCounter = 0;
          this.linearReload = 0;
          this.linearReloadFlag = false;
          this.timer = 0;
          this.timerPeriod = 0;
          this.sequencePos = 0;
          
          this.sequence = [
            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
          ];
        }
        
        write(addr, value) {
          switch (addr & 3) {
            case 0: // $4008
              this.lengthCounter.halt = (value & 0x80) !== 0;
              this.linearReload = value & 0x7F;
              break;
            case 2: // $400A
              this.timerPeriod = (this.timerPeriod & 0x700) | value;
              break;
            case 3: // $400B
              this.timerPeriod = (this.timerPeriod & 0xFF) | ((value & 7) << 8);
              this.lengthCounter.load((value >> 3) & 0x1F);
              this.linearReloadFlag = true;
              break;
          }
        }
        
        clockTimer() {
          if (this.timer === 0) {
            this.timer = this.timerPeriod;
            if (this.lengthCounter.counter > 0 && this.linearCounter > 0) {
              this.sequencePos = (this.sequencePos + 1) & 31;
            }
          } else {
            this.timer--;
          }
        }
        
        clockLinearCounter() {
          if (this.linearReloadFlag) {
            this.linearCounter = this.linearReload;
          } else if (this.linearCounter > 0) {
            this.linearCounter--;
          }
          
          if (!this.lengthCounter.halt) {
            this.linearReloadFlag = false;
          }
        }
        
        clockLength() {
          this.lengthCounter.clock();
        }
        
        output() {
          if (!this.enabled) return 0;
          if (this.lengthCounter.counter === 0) return 0;
          if (this.linearCounter === 0) return 0;
          if (this.timerPeriod < 2) return 0; // Ultrasonic
          return this.sequence[this.sequencePos];
        }
      }
      
      class Noise {
        constructor() {
          this.enabled = false;
          this.envelope = new Envelope();
          this.lengthCounter = new LengthCounter();
          this.mode = false;
          this.timer = 0;
          this.timerPeriod = 0;
          this.shift = 1;
          
          this.periodTable = [
            4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068
          ];
        }
        
        write(addr, value) {
          switch (addr & 3) {
            case 0: // $400C
              this.lengthCounter.halt = (value & 0x20) !== 0;
              this.envelope.loop = (value & 0x20) !== 0;
              this.envelope.constant = (value & 0x10) !== 0;
              this.envelope.volume = value & 0x0F;
              break;
            case 2: // $400E
              this.mode = (value & 0x80) !== 0;
              this.timerPeriod = this.periodTable[value & 0x0F];
              break;
            case 3: // $400F
              this.lengthCounter.load((value >> 3) & 0x1F);
              this.envelope.start = true;
              break;
          }
        }
        
        clockTimer() {
          if (this.timer === 0) {
            this.timer = this.timerPeriod;
            const feedback = (this.shift & 1) ^ ((this.shift >> (this.mode ? 6 : 1)) & 1);
            this.shift = (this.shift >> 1) | (feedback << 14);
          } else {
            this.timer--;
          }
        }
        
        clockEnvelope() {
          this.envelope.clock();
        }
        
        clockLength() {
          this.lengthCounter.clock();
        }
        
        output() {
          if (!this.enabled) return 0;
          if (this.lengthCounter.counter === 0) return 0;
          if ((this.shift & 1) !== 0) return 0;
          return this.envelope.output();
        }
      }
      
      class DMC {
        constructor(cpu) {
          this.cpu = cpu;
          this.enabled = false;
          this.irqEnabled = false;
          this.loop = false;
          this.timer = 0;
          this.timerPeriod = 0;
          this.sampleAddr = 0xC000;
          this.sampleLength = 0;
          this.currentAddr = 0xC000;
          this.bytesRemaining = 0;
          this.sampleBuffer = 0;
          this.sampleBufferEmpty = true;
          this.shiftRegister = 0;
          this.bitsRemaining = 0;
          this.outputLevel = 0;
          this.silence = true;
          
          this.rateTable = [
            428, 380, 340, 320, 286, 254, 226, 214,
            190, 160, 142, 128, 106, 84, 72, 54
          ];
        }
        
        write(addr, value) {
          switch (addr & 3) {
            case 0: // $4010
              this.irqEnabled = (value & 0x80) !== 0;
              this.loop = (value & 0x40) !== 0;
              this.timerPeriod = this.rateTable[value & 0x0F];
              break;
            case 1: // $4011
              this.outputLevel = value & 0x7F;
              break;
            case 2: // $4012
              this.sampleAddr = 0xC000 + (value * 64);
              break;
            case 3: // $4013
              this.sampleLength = (value * 16) + 1;
              break;
          }
        }
        
        start() {
          this.currentAddr = this.sampleAddr;
          this.bytesRemaining = this.sampleLength;
        }
        
        clockTimer() {
          if (this.timer === 0) {
            this.timer = this.timerPeriod;
            
            if (!this.silence) {
              if ((this.shiftRegister & 1) !== 0) {
                if (this.outputLevel <= 125) this.outputLevel += 2;
              } else {
                if (this.outputLevel >= 2) this.outputLevel -= 2;
              }
            }
            
            this.shiftRegister >>= 1;
            this.bitsRemaining--;
            
            if (this.bitsRemaining === 0) {
              this.bitsRemaining = 8;
              if (this.sampleBufferEmpty) {
                this.silence = true;
              } else {
                this.silence = false;
                this.shiftRegister = this.sampleBuffer;
                this.sampleBufferEmpty = true;
                this.fillBuffer();
              }
            }
          } else {
            this.timer--;
          }
        }
        
        fillBuffer() {
          if (this.sampleBufferEmpty && this.bytesRemaining > 0) {
            this.sampleBuffer = this.cpu.read(this.currentAddr);
            this.sampleBufferEmpty = false;
            this.currentAddr = (this.currentAddr === 0xFFFF) ? 0x8000 : this.currentAddr + 1;
            this.bytesRemaining--;
            
            if (this.bytesRemaining === 0) {
              if (this.loop) {
                this.start();
              } else if (this.irqEnabled) {
                // Trigger IRQ
              }
            }
          }
        }
        
        output() {
          return this.outputLevel;
        }
      }
      
      class APU {
        constructor(cpu) {
          this.cpu = cpu;
          this.pulse1 = new Pulse(1);
          this.pulse2 = new Pulse(2);
          this.triangle = new Triangle();
          this.noise = new Noise();
          this.dmc = new DMC(cpu);
          
          this.frameCounter = 0;
          this.frameMode = 0; // 0: 4-step, 1: 5-step
          this.irqInhibit = false;
          this.frameIRQ = false;
          
          this.cycles = 0;
          
          // Audio context
          this.audioContext = null;
          this.sampleRate = 44100;
          this.bufferSize = 4096;
          this.audioBuffer = [];
          this.audioNode = null;
        }
        
        initAudio() {
          if (this.audioContext) return;
          
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.sampleRate = this.audioContext.sampleRate;
          if (this.audioContext.state === 'suspended') {
    this.audioContext.resume();
  }
  this.gainNode = this.audioContext.createGain();
  this.gainNode.gain.value = 0.3;
          this.audioNode = this.audioContext.createScriptProcessor(this.bufferSize, 0, 1);
          this.audioNode.onaudioprocess = (e) => {
            const output = e.outputBuffer.getChannelData(0);
            for (let i = 0; i < output.length; i++) {
              output[i] = this.audioBuffer.shift() || 0;
            }
          };
          
          this.audioNode.connect(this.audioContext.destination);
           if (this.audioContext.state === 'suspended') {
              this.audioContext.resume();
            }
    
          
        } catch (e) {
           
          }
        
        write(addr, value) {
          switch (addr) {
            case 0x4000: case 0x4001: case 0x4002: case 0x4003:
              this.pulse1.write(addr, value);
              break;
            case 0x4004: case 0x4005: case 0x4006: case 0x4007:
              this.pulse2.write(addr, value);
              break;
            case 0x4008: case 0x400A: case 0x400B:
              this.triangle.write(addr, value);
              break;
            case 0x400C: case 0x400E: case 0x400F:
              this.noise.write(addr, value);
              break;
            case 0x4010: case 0x4011: case 0x4012: case 0x4013:
              this.dmc.write(addr, value);
              break;
            case 0x4015: // Status
              this.pulse1.enabled = (value & 0x01) !== 0;
              this.pulse2.enabled = (value & 0x02) !== 0;
              this.triangle.enabled = (value & 0x04) !== 0;
              this.noise.enabled = (value & 0x08) !== 0;
              this.dmc.enabled = (value & 0x10) !== 0;
              
              if (!this.pulse1.enabled) this.pulse1.lengthCounter.counter = 0;
              if (!this.pulse2.enabled) this.pulse2.lengthCounter.counter = 0;
              if (!this.triangle.enabled) this.triangle.lengthCounter.counter = 0;
              if (!this.noise.enabled) this.noise.lengthCounter.counter = 0;
              if (this.dmc.enabled) this.dmc.start();
              else this.dmc.bytesRemaining = 0;
              break;
            case 0x4017: // Frame counter
              this.frameMode = (value >> 7) & 1;
              this.irqInhibit = (value & 0x40) !== 0;
              if (this.irqInhibit) this.frameIRQ = false;
              
              // Reset sequence
              this.frameCounter = 0;
              if (this.frameMode === 1) {
                this.clockEnvelopes();
                this.clockSweepsAndLength();
              }
              break;
          }
        }
        
        read(addr) {
          if (addr === 0x4015) {
            let status = 0;
            if (this.pulse1.lengthCounter.counter > 0) status |= 0x01;
            if (this.pulse2.lengthCounter.counter > 0) status |= 0x02;
            if (this.triangle.lengthCounter.counter > 0) status |= 0x04;
            if (this.noise.lengthCounter.counter > 0) status |= 0x08;
            if (this.dmc.bytesRemaining > 0) status |= 0x10;
            if (this.frameIRQ) status |= 0x40;
            
            this.frameIRQ = false;
            return status;
          }
          return 0;
        }
        
        step() {
          this.cycles++;
          
          // Clock timers every CPU cycle
          if (this.cycles % 2 === 0) { // APU runs at CPU rate / 2
            this.pulse1.clockTimer();
            this.pulse2.clockTimer();
            this.noise.clockTimer();
            this.dmc.clockTimer();
          }
          
          this.triangle.clockTimer();
          
          // Frame counter
          this.clockFrameCounter();
          
          // Generate audio sample
          this.generateSample();
        }
        
        clockFrameCounter() {
          const step = this.cycles;
          
          if (this.frameMode === 0) { // 4-step
            if (step === 7457) this.clockEnvelopes();
            if (step === 14913) {
              this.clockEnvelopes();
              this.clockSweepsAndLength();
            }
            if (step === 22371) this.clockEnvelopes();
            if (step === 29828) {
              this.clockEnvelopes();
              this.clockSweepsAndLength();
              if (!this.irqInhibit) this.frameIRQ = true;
            }
            if (step === 29829) {
              if (!this.irqInhibit) this.frameIRQ = true;
            }
            if (step === 29830) {
              if (!this.irqInhibit) this.frameIRQ = true;
              this.cycles = 0;
            }
          } else { // 5-step
            if (step === 7457) this.clockEnvelopes();
            if (step === 14913) {
              this.clockEnvelopes();
              this.clockSweepsAndLength();
            }
            if (step === 22371) this.clockEnvelopes();
            if (step === 37281) {
              this.clockEnvelopes();
              this.clockSweepsAndLength();
            }
            if (step === 37282) {
              this.cycles = 0;
            }
          }
        }
        
        clockEnvelopes() {
          this.pulse1.clockEnvelope();
          this.pulse2.clockEnvelope();
          this.triangle.clockLinearCounter();
          this.noise.clockEnvelope();
        }
        
        clockSweepsAndLength() {
          this.pulse1.clockSweep();
          this.pulse1.clockLength();
          this.pulse2.clockSweep();
          this.pulse2.clockLength();
          this.triangle.clockLength();
          this.noise.clockLength();
        }
        
        generateSample() {
          const cpuFreq = 1789773;
          const interval = cpuFreq / this.sampleRate;
          
          if (this.cycles % Math.floor(interval) !== 0) return;
          
          // Mix channels
          const p1 = this.pulse1.output();
          const p2 = this.pulse2.output();
          const tri = this.triangle.output();
          const noi = this.noise.output();
          const dmc = this.dmc.output();
          
          // Mixer (non-linear)
          let pulseOut = 0;
          if (p1 !== 0 || p2 !== 0) {
            pulseOut = 95.88 / ((8128 / (p1 + p2)) + 100);
          }
          
          let tndOut = 0;
          if (tri !== 0 || noi !== 0 || dmc !== 0) {
            tndOut = 159.79 / ((1 / ((tri / 8227) + (noi / 12241) + (dmc / 22638))) + 100);
          }
          
          const sample = pulseOut + tndOut;
          
          this.audioBuffer.push(sample);
          
          // Limit buffer size
          if (this.audioBuffer.length > this.bufferSize * 4) {
            this.audioBuffer.shift();
          }
        }
      }

class Controller {
  constructor() {
    this.state = 0;
    this.latch = 0;
    this.strobe = 0;
    this.index = 0;
  }

  write(val) {
    this.strobe = val & 1;

    if (this.strobe) {
      // ストローブが1の間は常にAボタンを返す
      this.latch = this.state;
      this.index = 0;
    } else {
      // 1→0に変化した瞬間だけ index をリセット
      this.latch = this.state;
      this.index = 0;
    }
  }

  read() {
    let ret = 0;

    if (this.strobe) {
      // ストローブが1の間は常にAボタン
      ret = this.state & 1;
    } else {
      // ストローブが0のときはシフト読み取り
      if (this.index < 8) {
        ret = (this.latch >> this.index) & 1;
      } else {
        ret = 1;
      }
      this.index++;
    }

    return ret;
  }

  setButtons({ A, B, Select, Start, Up, Down, Left, Right }) {
    let s = 0;
    if (A) s |= 1 << 0;
    if (B) s |= 1 << 1;
    if (Select) s |= 1 << 2;
    if (Start) s |= 1 << 3;
    if (Up) s |= 1 << 4;
    if (Down) s |= 1 << 5;
    if (Left) s |= 1 << 6;
    if (Right) s |= 1 << 7;
    this.state = s;
  }
}

// 押しっぱなし対応（マウス・タッチ両方
     
class Bus {
  constructor() {
    this.cpu = new CPU(this);
    this.cpuRAM = new Uint8Array(0x800);
    this.cartridge = null;
    this.mapper = null;
    this.apu = new APU(this.cpu);
    this.ppu = new PPU(this); // PPU は後で設定
    this.ctrl1 = new Controller();
    this.ctrl2 = new Controller();
    this.nmiLine = false;
    this.irqLine = false;
  }

  insertCartridge(cart) {
    
    this.cartridge = cart;
  this.mapper = createMapper(cart, this);
this.fds = null;
  }
attachFDS(fds,cart) {
  this.fds = fds;
this.cartridge = null;

  cart.mapper = 20


}

  cpuRead(addr) {
    addr &= 0xffff;
   if (this.fds && addr >= 0x4020 && addr <= 0x403F) {
    return this.fds.ioRead(addr);
  }
    if (this.fds) {
      // FDS I/O 領域を 0x4030 からにする


     // ★ FDS I/O 全域を先に捕まえる


      // FDS RAM ($6000-$DFFF)
      if (addr >= 0x6000 && addr <= 0xDFFF) { // 範囲をDFFFまで広げる
        return this.fds.cpuRead(addr);
      }
      // FDS BIOS
      if (addr >= 0xE000) {
        return this.fds.cpuRead(addr);
      }
    }

 
    if (addr < 0x2000) return this.cpuRAM[addr & 0x7ff];
    if (addr < 0x4000) return this.ppu.cpuRead(0x2000 + (addr & 7));
 if (addr >= 0x4000 && addr <= 0x4015) return this.apu.read(addr);
    if (addr === 0x4016) return this.ctrl1.read();
    if (addr === 0x4017) return this.ctrl2.read();

     if (this.mapper) {
    if (addr >= 0x6000 && addr < 0x8000) return this.mapper.cpuRead(addr);
    if (addr >= 0x8000) return this.mapper.cpuRead(addr);
  }

    return 0;
  }

  cpuWrite(addr, val) {
    addr &= 0xffff;
    val &= 0xff;
   if (this.fds) {
    if (addr >= 0x4020 && addr <= 0x402F) {
      this.fds.ioWrite(addr, val);
      return;
    }
    if (addr >= 0x6000) {
      this.fds.cpuWrite(addr, val);
      return;
    }
  }
  
    if (addr < 0x2000) {
      this.cpuRAM[addr & 0x7ff] = val;
      return;
    }
    if (addr < 0x4000) {
      this.ppu.cpuWrite(0x2000 + (addr & 7), val);
      return;
    }
    if (addr >= 0x4000 && addr <= 0x4013) {
    this.apu.write(addr, val);
    return;
  }
  if (addr === 0x4015) {
    this.apu.write(addr, val);
    return;
  }
  if (addr === 0x4017) {
    this.apu.write(addr, val);
    return;
  }
    if (addr === 0x4014) {
      const base = val << 8;
      this.cpu.cycles += this.cpu.cycles & 1 ? 514 : 513;
      for (let i = 0; i < 256; i++) {
        this.ppu.oam[i] = this.cpuRead(base + i);
      }
      return;
    }
    if (addr === 0x4016) {
      this.ctrl1.write(val);
      this.ctrl2.write(val);
      return;
    }
    if (this.mapper) {

    if (addr >= 0x6000 && addr < 0x8000) {
      this.mapper.cpuWrite(addr, val);
      return;
    }
    if (addr >= 0x8000) {
      this.mapper.cpuWrite(addr, val);
      return;
    }
  }
  }

  cartCHRRead(addr) {
    if (this.fds) {
    return this.fds.ppuRead(addr);
  }
  if (this.mapper) {
    return this.mapper.ppuRead(addr);
  }
    //return this.mapper.ppuRead(addr);
    return 0;
  }
  
  cartCHRWrite(addr, val) {
    if (this.fds) {
    this.fds.ppuWrite(addr, val);
    return;
  }

  if (this.mapper) {
    this.mapper.ppuWrite(addr, val);
  }
   // this.mapper.ppuWrite(addr, val);
  }
  
  ntMirror(addr) {
if (!this.mapper) {
    return (addr - 0x2000) & 0x0FFF; // FDS用
  }
    const a = (addr - 0x2000) & 0x0fff;
    const table = (a >> 10) & 3;
    const offset = a & 0x03ff;
   const m = this.mapper ? this.mapper.mirroring() : 0;

    const map = m === 0 ? [0, 0, 1, 1] : [0, 1, 0, 1];
    return map[table] * 0x400 + offset;
  }
  
  requestNMI() {
    this.nmiLine = true;
  }
  
  takeNMI() {
    if (this.nmiLine) {
      this.nmiLine = false;
      return true;
    }
    return false;
  }
  takeIRQ() {
  return this.irqLine;
}

  requestIRQ() {
    this.irqLine = true;
  }
  
 
}
class FDS {
  constructor(bus, bios, disk,cpu) {
    this.bus = bus;
    this.bios = bios; // 8KB
    this.disk = disk; // .fds raw
    this.cpu = cpu;
    // ★ RAM初期化を修正
   this.ram = new Uint8Array(0x8000); 

    this.ram.fill(0xFF); // ← 0x00ではなく0xFFで初期化
// FDS RAM (battery-backed)
this.fakeRamValue = 0x00;


    this.chr = new Uint8Array(0x2000); // ★ 8KB CHR-RAM
    // Disk state
if (this.disk[0] === 0x46 && this.disk[1] === 0x44 && this.disk[2] === 0x53) {
        this.dataOffset = 0x10;
        
    } else {
        this.dataOffset = 0x00;
       
    }
    this.diskPtr = 0x10;
    this.motorOn = false;
    this.irqEnabled = false;
    this.bus.irqLine = false;

this.headAtReset = true;
this.diskWait = 0;

    this.dataReady = false;
    this.irqFlag = false;
this.headResetDelay = 2000;
this.reset();
  }
reset() {
    
    // 初期化時は判定したオフセットを使用
    this.diskPtr = this.dataOffset; 
    this.resetTransfer = false; 
    this.motorOn = false;
    this.irqEnabled = false;
    this.timerIrq = false;
    this.transferIrq = false;
    this.writeSkip = 0;
    this.diskInserted = true; // ディスク挿入状態
    this.transferCycles = 0;
  }
 tick(cycles) {
if (this.diskPtr >= this.disk.length) {
    this.motorOn = false; // ディスク末尾に達したら強制停止（安全策）
    this.dataReady = false;
    this.bus.irqLine = false;
    return;
}
  if (!this.motorOn) return;
if (this.diskWait > 0) {
    this.diskWait--;
    return;
  }
  /* ---- ヘッドリセット ---- */
  // tick()
if (this.headAtReset) {
  this.headResetDelay -= cycles; 
  if (this.headResetDelay <= 0) {

    this.headAtReset = false;
this.transferCycles = -1500000; 
  }
  return;
}
// tick内



  /* ---- 転送タイミング ---- */
  this.transferCycles += cycles;

  if (this.transferCycles >= 200) {
    this.transferCycles -= 200;
if (this.diskPtr >= this.disk.length) {

    this.dataReady = false;
    this.irqFlag = false;
    this.bus.irqLine = false; // 割り込みを物理的に停止
    return; // これ以上何もしない
  }

if (this.transferCycles < 0) return; 
    // ★ ここが超重要
    if (!this.dataReady && this.diskPtr < this.disk.length) {

      this.dataReady = true;
//if (this.irqEnabled) {

      //this.irqFlag = true;
      this.bus.requestIRQ();
    //}
      //this.irqFlag = true;
      //this.bus.requestIRQ();
//this.diskWait = 150;
    }
  }
}



initBatteryRAM() {
    
    this.ram[0x0000] = 0x53; // 'S'
    this.ram[0x0001] = 0x41; // 'A'
    this.ram[0x0002] = 0x56; // 'V'
    this.ram[0x0003] = 0x00;
  }
ioRead(addr) {
  
// BIOS battery check workaround


  switch (addr) {


  case 0x4030: { // データ読み込み

  const data = this.disk[this.diskPtr] ?? 0x00;
this.dataReady = false;

        this.irqFlag = false;   // ★重要：IRQを解除
        this.bus.irqLine = false; 
 if (this.motorOn) {
        this.diskPtr++;
        this.dataReady = false; // ★重要：読んだのでフラグを下ろす
        this.irqFlag = false;   // ★重要：IRQを解除
        this.bus.irqLine = false; 
    }
 
 
 
  return data;
}

    case 0x4031: // ディスクステータス
  let s4031 = 0x00;

  if (this.irqFlag) s4031 |= 0x80;    // Bit7: IRQ
  if (this.dataReady) s4031 |= 0x02; // Bit1: Data Ready
 // this.irqFlag = false;
  //this.bus.irqLine = false;
  s4031 |= 0x01;
  return s4031;

case 0x4032: {
    // FDSのステータスは「0」がアクティブな項目が多い
    // Bit 6 は常に 1 (ディスクドライブの存在)
    let v = 0x40; 

    // Bit 0: 0=Ready (挿入済み), 1=Not Ready
    // ここを 1 にすると BIOS は「ディスクを入れろ」と言い、
    // 0 にすると「Now Loading」に進みます。
   if (!this.diskInserted) v |= 0x01;
//v &= ~0x01;
if (this.headAtReset) v |= 0x02;
    // Bit 1: 0=スキャン中(ヘッドがデータ領域にある), 1=リセット位置
    // BIOS はここが 1 から 0 に変わることで「回転が安定した」と判断することがあります。
    //if (this.diskPtr === this.dataOffset) {

   //     v |= 0x02;
  //  } else {

    // Bit 2: 0=書き込み可, 1=書き込み禁止
    // v |= 0x04; // セーブできない場合はここをコメントアウト

    return v;
}

  case 0x4023: {
  let v = 0x40; // bit6 = disk inserted

  if (this.dataReady) v |= 0x01; // bit0
  if (this.irqFlag)   v |= 0x02; // bit1

  

  return v;
}

    case 0x4033: // External connector
      //return 0x80;
      return 0x81; 
case 0x4024:
case 0x4025: {

  let v = 0x00;
  if (this.motorOn) v |= 0x01;     // bit0 = motor
  if (this.irqEnabled) v |= 0x80;  // bit7 = IRQ enable
  return v;
}

case 0x4026: // IRQ RESET
  
  this.irqFlag = false;
  this.bus.irqLine = false; // ← ★ これが無かった
  break;

case 0x4027:
  return 0x00;

   }

  return 0;
}
ioWrite(addr, val) {
 
    if (addr >= 0x6000 && addr <= 0x7FFF) {
    this.ram[addr - 0x6000] = val & 0xFF;
    return;
  }
  switch (addr) {
   case 0x4025:
  this.motorOn = (val & 0x01) !== 0; // ★ bit1

 
  const reset = (val & 0x02) !== 0;      // bit2

 
 if ((val & 0x02) === 0) {
    this.headAtReset = true;
    this.diskPtr = this.dataOffset;
    this.headResetDelay = 90000; // BIOSがホーム位置を確認できる十分な時間
    this.dataReady = false;
    this.irqFlag = false;
    this.bus.irqLine = false;
  }

  // ★重要：Bit 7 が IRQ イネーブル
  this.irqEnabled = (val & 0x80) !== 0;
  
  if (!this.irqEnabled) {
    this.irqFlag = false;
    this.bus.irqLine = false;
  }

  if (val & 0x04) {
        //this.diskPtr = this.dataOffset;
        this.dataReady = false;
    }
if (this.motorOn) {
    this.dataReady = false;
  }
  

  
  break;


    // ioRead(0x4026) または ioWrite(0x4026) の両方でクリアを試みる
case 0x4026:
  this.irqFlag = false;
  this.bus.irqLine = false; // CPUへの割り込み信号を確実に下げる
  return 0; // Readの場合は0

  

case 0x4020: // IRQ制御
      this.irqEnabled = (val & 0x01) !== 0;
      
      if (val & 0x01) {
        // IRQ有効化
        this.irqFlag = false;
      } else {
        // IRQ無効化・クリア
        this.irqFlag = false;
      }
      
      
      break;

    case 0x4024: // Disk write data
      if (this.motorOn && this.diskPtr < this.disk.length) {
        this.disk[this.diskPtr++] = val & 0xFF;
      }
      break;

}}

ppuRead(addr) {
    return this.chr[addr & 0x1FFF];
  }

  ppuWrite(addr, val) {
    this.chr[addr & 0x1FFF] = val;
  }
  cpuRead(addr) {
  // ★ I/O は絶対にここで触らない
  if (addr >= 0x4020 && addr <= 0x403F) {
    return 0; // Bus 側で処理させる
  }

  // FDS RAM
  if (addr >= 0x6000 && addr <= 0xDFFF) {
    return this.ram[addr - 0x6000];
  }

  // BIOS
  if (addr >= 0xE000) {
    return this.bios[addr - 0xE000];
  }

  return 0;
}


cpuWrite(addr, val) {
    // FDS RAM 領域への書き込み: $6000 - $DFFF
    if (addr >= 0x6000 && addr <= 0xDFFF) {
        this.ram[addr - 0x6000] = val & 0xFF;
        // ログが多すぎる場合は、動作確認後に下の1行を消してください
        // console.log("[FDS RAM WRITE]", addr.toString(16), val.toString(16));
    }
  }
}

      // NESのボタン名とキーコードの対応
      const keyMapP1 = {
        KeyX: "A", // Aボタン
        KeyZ: "B", // Bボタン
        ShiftLeft: "Select",
        Enter: "Start",
        ArrowUp: "Up",
        ArrowDown: "Down",
        ArrowLeft: "Left",
        ArrowRight: "Right",
      };
      // Player1のボタン状態
      const buttonsP1 = {
        A: false,
        B: false,
        Select: false,
        Start: false,
        Up: false,
        Down: false,
        Left: false,
        Right: false,
      };
      window.addEventListener("keydown", (e) => {
        if (keyMapP1[e.code] !== undefined) {
          
          buttonsP1[keyMapP1[e.code]] = true;
          nes.bus.ctrl1.setButtons(buttonsP1);
          e.preventDefault(); // ブラウザのスクロール等を防ぐ
        }
      });

      window.addEventListener("keyup", (e) => {
        if (keyMapP1[e.code] !== undefined) {
          buttonsP1[keyMapP1[e.code]] = false;
          nes.bus.ctrl1.setButtons(buttonsP1);
          e.preventDefault();
        }
      });
let stepCount = 0;
let lastPC = -1;
let sameCount = 0;
      const font8x8 = {
        A: [0x18, 0x24, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00],
        " ": [0, 0, 0, 0, 0, 0, 0, 0], // 空白
        "?": [
          0b0111110, 0b1000001, 0b0000010, 0b0001100, 0b0001000, 0b0000000,
          0b0001000, 0b0000000,
        ],
        B: [0x7c, 0x42, 0x42, 0x7c, 0x42, 0x42, 0x7c, 0x00],
        C: [0x3c, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3c, 0x00],
        D: [0x78, 0x44, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00],
        E: [0x7e, 0x40, 0x40, 0x7c, 0x40, 0x40, 0x7e, 0x00],
        F: [0x7e, 0x40, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x00],
        G: [0x3c, 0x42, 0x40, 0x4e, 0x42, 0x42, 0x3c, 0x00],
        H: [0x42, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00],
        I: [0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00],
        J: [0x0e, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00],
        K: [0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00],
        L: [0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00],
        M: [0x42, 0x66, 0x5a, 0x5a, 0x42, 0x42, 0x42, 0x00],
        N: [0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x42, 0x00],
        O: [0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00],
        P: [0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x40, 0x00],
        Q: [0x3c, 0x42, 0x42, 0x42, 0x4a, 0x44, 0x3a, 0x00],
        R: [0x7c, 0x42, 0x42, 0x7c, 0x48, 0x44, 0x42, 0x00],
        S: [0x3c, 0x42, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00],
        T: [0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
        U: [0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00],
        V: [0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00],
        W: [0x42, 0x42, 0x42, 0x5a, 0x5a, 0x66, 0x42, 0x00],
        X: [0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42, 0x00],
        Y: [0x42, 0x42, 0x24, 0x18, 0x18, 0x18, 0x18, 0x00],
        Z: [0x7e, 0x02, 0x04, 0x18, 0x20, 0x40, 0x7e, 0x00],
        // 他の文字も定義
      };
      // 8x8 フォント定義（大文字 A〜Z）

      PPU.prototype.drawChar = function (px, py, ch, color = 0xffffffff) {
        const glyph = font8x8[ch] || font8x8["?"];
        if (!glyph) return; // 念のため
        for (let row = 0; row < 8; row++) {
          const bits = glyph[row];
          for (let col = 0; col < 8; col++) {
            if ((bits >> (7 - col)) & 1) {
              const dst = (py + row) * 256 + (px + col);
              this.framebuffer[dst] = color;
            }
          }
        }
      };

      PPU.prototype.drawText = function (px, py, text, color = 0xffffffff) {
        for (let i = 0; i < text.length; i++) {
          this.drawChar(px + i * 8, py, text[i], color);
        }
      };
      function showStartupMessage(ppu) {
        // 背景を黒で塗りつぶし
        ppu.framebuffer.fill(0xff000000);
        const imageData = ctx.createImageData(256, 240);
        // メッセージを描画
        ppu.drawText(40, 100, "NES EMULATOR", 0xffffff00);
        ppu.drawText(40, 120, "PRESS START", 0xffffffff);
        const buf = new Uint32Array(imageData.data.buffer);
        buf.set(ppu.framebuffer);
        ctx.putImageData(imageData, 0, 0);
        // 画面に反映
        ppu.renderFrame();
      }

      class NES {
        constructor() {
          this.bus = new Bus();
        
          this.cpu = new CPU(this.bus);
          this.ppu = this.bus.ppu;
          
          this.running = false;
        }
        loadCartridge(bytes) {
          const cart = new Cartridge(bytes);
console.log(cart.mapper);
           if (!cart.valid) throw new Error("Unsupported ROM");
          this.bus.insertCartridge(cart);
          
          this.bus.apu.initAudio();
          this.cpu.reset();
          //this.ppu.reset();
        }
        loadDisk(bytes){
          this.fds = new FDS(this.bus, fdsBios, fdsDisk,this.cpu)
          const cart = new Cartridge(fdsDisk);
          this.bus.attachFDS(this.fds,cart);
          this.bus.apu.initAudio();
          this.cpu.reset(0xE000); 
        }
         stepFrame() {
            const pc = this.cpu.PC;
    
    // 無限ループ検出
    if (pc === lastPC) {
      sameCount++;
      if (sameCount > 1000) {
        return; // 停止
      }
    } else {
      lastPC = pc;
      sameCount = 0;
    }
 let guard = 0;

while (!this.ppu.consumeFrameFlag()) {
    const cpuCycles = this.cpu.step();

    

    for (let i = 0; i < cpuCycles; i++) {
        this.bus.apu.step();
        this.ppu.step();
        this.ppu.step();
        this.ppu.step();
    }

    if (++guard > 10_000_000) {
        
        break;
    }
  }
}

        // === NES.stepFrame の安全化（step を二回呼んでいる箇所を修正、PC 繰り返し検出を追加） ===
        stepFDS() {
            const pc = this.cpu.PC;
    
    // 無限ループ検出
    if (pc === lastPC) {
      sameCount++;
      if (sameCount > 1000) {
        return; // 停止
      }
    } else {
      lastPC = pc;
      sameCount = 0;
    }
  
 let guard = 0;

while (!this.ppu.consumeFrameFlag()) {
    const cpuCycles = this.cpu.step();

    this.bus.fds.tick(cpuCycles);

    for (let i = 0; i < cpuCycles; i++) {
        this.bus.apu.step();
        this.ppu.step();
        this.ppu.step();
        this.ppu.step();
    }

    if (++guard > 10_000_000) {
        
        break;
    }
  }
}
  }    
      // ---------- UI / Main loop ----------
      const canvas = document.getElementById("screen");
      const ctx = canvas.getContext("2d", { alpha: true });
      const status = document.getElementById("status");
      const startBtn = document.getElementById("start");
      const romInput = document.getElementById("rom");
      const fpsEl = document.getElementById("fps");
      const pcEl = document.getElementById("pc");
      const cycEl = document.getElementById("cyc");
      const ppuEl = document.getElementById("pcp");
      const ppXEl = document.getElementById("ppx");
      const ramEl = document.getElementById("ram");
      const mapperEl = document.getElementById("mapper");
      const romSelect = document.getElementById("romSelect");
      let nes = new NES();
      let romBytes = null;

      const fullscreenBtn = document.getElementById("fullscreenBtn");

      fullscreenBtn.addEventListener("click", () => {
        if (!document.fullscreenElement) {
          // キャンバスをフルスクリーンに
          canvas.requestFullscreen().catch((err) => {
           
          });
        } else {
          // フルスクリーン解除
          document.exitFullscreen();
        }
      });
      romSelect.addEventListener("change", async (e) => {
  const url = e.target.value;
  if (!url) return;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("Failed to load " + url);
    const buf = await res.arrayBuffer();
    romBytes = new Uint8Array(buf);
    const fileName = url.split("/").pop();
   
    startBtn.disabled = false;
  } catch (err) {
    status.textContent = "Error: " + err.message;
  }
});
      romInput.addEventListener("change", async (e) => {
        const f = e.target.files[0];
        if (!f) return;
        const buf = await f.arrayBuffer();
        romBytes = new Uint8Array(buf);
        status.textContent = `Loaded`;
        startBtn.disabled = false;
      });
       
const BUTTON_MAP = {
  0: "A",
  1: "B",
  8: "Select",
  9: "Start",
};

let prevButtons = [];
let prevAxes = [0, 0];

function handlePadInput(pad) {
  // ボタン
  
  pad.buttons.forEach((btn, index) => {
    const nesBtn = BUTTON_MAP[index];
    if (nesBtn !== undefined) {
      if (btn.pressed && !prevButtons[index]) {
        
        buttonsP1[nesBtn] = true;
          nes.bus.ctrl1.setButtons(buttonsP1);
      } else if (!btn.pressed && prevButtons[index]) {

       
        buttonsP1[nesBtn] = false;
          nes.bus.ctrl1.setButtons(buttonsP1);
      }
    }
  });

  // 十字キー（axes）
  const [axX, axY] = pad.axes;

  // 左右
  if (axX < -0.5 && prevAxes[0] >= -0.5) {buttonsP1["Left"] = true;nes.bus.ctrl1.setButtons(buttonsP1);}
  if (axX >= -0.5 && prevAxes[0] < -0.5) {buttonsP1["Left"] = false;nes.bus.ctrl1.setButtons(buttonsP1);}

  if (axX > 0.5 && prevAxes[0] <= 0.5) {buttonsP1["Right"] = true;nes.bus.ctrl1.setButtons(buttonsP1);}
  if (axX <= 0.5 && prevAxes[0] > 0.5) {buttonsP1["Right"] = false;nes.bus.ctrl1.setButtons(buttonsP1);}

  // 上下
  if (axY < -0.5 && prevAxes[1] >= -0.5) {buttonsP1["Up"] = true;nes.bus.ctrl1.setButtons(buttonsP1);}
  if (axY >= -0.5 && prevAxes[1] < -0.5) {buttonsP1["Up"] = false;nes.bus.ctrl1.setButtons(buttonsP1);}

  if (axY > 0.5 && prevAxes[1] <= 0.5) {buttonsP1["Down"] = true;nes.bus.ctrl1.setButtons(buttonsP1);}
  if (axY <= 0.5 && prevAxes[1] > 0.5) {buttonsP1["Down"] = false;nes.bus.ctrl1.setButtons(buttonsP1);}

  prevButtons = pad.buttons.map(b => b.pressed);
  prevAxes = [axX, axY];
}
      let lastTime = performance.now();
      let frames = 0,
        lastFpsTime = lastTime;
document.getElementById("fdsBios").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  file.arrayBuffer().then(buf => {
    fdsBios = new Uint8Array(buf);
    
  });
});


document.getElementById("fdsDisk").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  file.arrayBuffer().then(buf => {
    const raw = new Uint8Array(buf);
    fdsDisk = raw;
   
  });
});


      startBtn.addEventListener("click", () => {
        try {
          
          if (fdsBios && fdsDisk) {
            nes = new NES();
    isFDS = true;


    //let fds = new FDS(nes.bus, fdsBios, fdsDisk);
    nes.loadDisk(null);
    //nes.cpu.reset(0xE000); // BIOS entry
    nes.stepFDS();

          loop();
  } else {
     isFDS = false;
          nes = new NES();

          nes.loadCartridge(romBytes);

          nes.stepFrame();

          loop();

          status.textContent = "Running (skeleton)";
  }
        } catch (e) {
          console.error(e);
          status.textContent = "Error: " + e.message;
        }
      });
  const imageData = ctx.createImageData(256, 240);
let recorder = null;
let recChunks = [];
let recording = false;

const recCanvas  = document.getElementById("rec");


const recCtx  = recCanvas.getContext("2d", { alpha:false });


recCtx.imageSmoothingEnabled  = false;
      function loop() {
        try {
          if(!isFDS){
          nes.stepFrame();
}else{
nes.stepFDS();
}
        } catch (e) {
          status.textContent = "Stopped: " + e.message;
          return;
        }
const pads = navigator.getGamepads();
  if (pads[0]) {
    handlePadInput(pads[0]);
  }
      
        const data = imageData.data;
        const fb = nes.ppu.framebuffer;
document.getElementById("pc").textContent = "0x"+nes.cpu.PC.toString(16)
        for (let i = 0; i < fb.length; i++) {
          const color = fb[i] >>> 0; // 符号付きシフトを避ける
          const offset = i * 4;
          // NES_PALETTE の値が 0xRRGGBBAA のとき（例: 0x666666FF）
          data[offset + 0] = (color >>> 24) & 0xff; // R
          data[offset + 1] = (color >>> 16) & 0xff; // G
          data[offset + 2] = (color >>> 8) & 0xff; // B
          data[offset + 3] = (color >>> 0) & 0xff; // A
        }

        ctx.putImageData(imageData, 0, 0);
         const border = 8;

  // 外枠いっぱいに塗る場合（中を塗りつぶす）
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, canvas.width, border);                     // 上
  ctx.fillRect(0, canvas.height - border, canvas.width, border); // 下
  ctx.fillRect(0, 0, border, canvas.height);                     // 左
  ctx.fillRect(canvas.width - border, 0, border, canvas.height); // 右
        // Stats
        frames++;
        const now = performance.now();
        if (now - lastFpsTime >= 1000) {
          fpsEl.textContent = frames.toString();
          frames = 0;
          lastFpsTime = now;
        }

        
        recCtx.clearRect(0, 0, recCanvas.width, recCanvas.height);
  recCtx.drawImage(
    canvas,
    0, 0, 256, 240,
    0, 0, recCanvas.width, recCanvas.height
  );
        

        requestAnimationFrame(loop);
      }


function setRecordResolution(on) {
  if (on) {
    canvas.width  = 256 * 3; // ← 3倍（768x720）
    canvas.height = 240 * 3;
    ctx.imageSmoothingEnabled = false;
  } else {
    canvas.width  = 256;
    canvas.height = 240;
    ctx.imageSmoothingEnabled = false;
  }
}

function startRecording() {
  if (recording) return;

  const stream = recCanvas.captureStream(60);

  recorder = new MediaRecorder(stream, {
    mimeType: "video/webm; codecs=vp9",
    videoBitsPerSecond: 20_000_000
  });

  recChunks = [];

  recorder.ondataavailable = e => {
    if (e.data.size > 0) recChunks.push(e.data);
  };

  recorder.onstop = () => {
    const blob = new Blob(recChunks, { type: "video/webm" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "nes_60fps.webm";
    a.click();

    URL.revokeObjectURL(url);
  };

  recorder.start();
  recording = true;
  console.log("● REC");
}

function stopRecording() {
  if (!recording || !recorder) return;

  recorder.stop();
  recording = false;
  recorder = null;
  console.log("■ STOP");
}
window.addEventListener("keydown", e => {
  if (e.repeat) return;

  // R キーでトグル
  if (e.code === "KeyR" && !e.shiftKey) {
    e.preventDefault();
    recording ? stopRecording() : startRecording();
  }

  // Shift + R で強制停止
  if (e.code === "KeyR" && e.shiftKey) {
    e.preventDefault();
    stopRecording();
  }
});

    </script>

<canvas id="rec" width="768" height="720" style="display:none"></canvas>
  </body>
</html>